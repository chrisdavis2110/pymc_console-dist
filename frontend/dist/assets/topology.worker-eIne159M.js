!function(){"use strict";const t=.6,e=100;function o(t){return 1===t||0===t}function n(t){return 2===t||3===t}function s(t){return t.startsWith("0x")||t.startsWith("0X")?t.slice(2,4).toUpperCase():t.slice(0,2).toUpperCase()}function i(t,e){let o=t.forwarded_path??t.original_path;if("string"==typeof o)try{o=JSON.parse(o)}catch{return null}if(!o||!Array.isArray(o)||0===o.length)return null;const n=o.map(t=>String(t).toUpperCase()),i=e?s(e):null,r=n[n.length-1],a=null!==i&&r===i,c=a?n.slice(0,-1):[...n];return{effective:c,original:n,hadLocal:a,effectiveLength:c.length}}function r(t,e){return e-t}function a(t){return t}function c(t,e,o,n){const s=(o-t)*Math.PI/180,i=(n-e)*Math.PI/180,r=Math.sin(s/2)*Math.sin(s/2)+Math.cos(t*Math.PI/180)*Math.cos(o*Math.PI/180)*Math.sin(i/2)*Math.sin(i/2);return 2*Math.atan2(Math.sqrt(r),Math.sqrt(1-r))*6371e3}function u(t){return t<500?1:t<2e3?.8:t<5e3?.6:t<1e4?.4:t<2e4?.2:.1}function f(t){if(t.contact_type){const e=t.contact_type.toLowerCase();if("repeater"===e||"rep"===e)return!0;if("companion"===e||"client"===e||"cli"===e)return!1;if("room server"===e||"room_server"===e||"room"===e||"server"===e)return!1}return!0===t.is_repeater||(t.is_repeater,!1)}function l(t,e){if(!t||t<=0)return.1;const o=(Math.floor(Date.now()/1e3)-t)/3600;return o<0?1:Math.exp(-o/12)}function h(t){return!(!t||t<=0)&&(Math.floor(Date.now()/1e3)-t)/3600>336}function d(t,e,o){const n=e.toUpperCase(),s=t.get(n);if(!s||0===s.candidates.length)return{hash:null,confidence:0};if(null==o?void 0:o.isLastHop)return{hash:s.bestMatch,confidence:s.confidence};if(1===(null==o?void 0:o.position))return{hash:s.bestMatch,confidence:s.confidence};if((null==o?void 0:o.position)&&s.bestMatchForPosition.has(o.position)){const t=s.bestMatchForPosition.get(o.position),e=Math.max(t.confidence,s.confidence);return{hash:t.hash,confidence:e}}if((null==o?void 0:o.adjacentPrefixes)&&o.adjacentPrefixes.length>0){let t=s.bestMatch,e=0;for(const n of s.candidates){let s=0;for(const t of o.adjacentPrefixes)s+=n.adjacentPrefixCounts.get(t.toUpperCase())||0;const i=n.combinedScore+s/Math.max(1,n.totalAdjacentObservations)*.3;i>e&&(e=i,t=n.hash)}return{hash:t,confidence:s.confidence}}return{hash:s.bestMatch,confidence:s.confidence}}function p(t){return"known"===t.type}function g(t,e,o,n){const s=t*Math.PI/180,i=e*Math.PI/180,r=o*Math.PI/180,a=r-s,c=n*Math.PI/180-i,u=Math.sin(a/2)**2+Math.cos(s)*Math.cos(r)*Math.sin(c/2)**2;return 2*Math.atan2(Math.sqrt(u),Math.sqrt(1-u))*6371}function m(t,e,o){const n=[];let s=0;for(const i of e){const e=-Math.log(Math.max(i.recencyScore,.01));let o=Math.min(e,5);i.confidence>=.8?o=Math.max(0,o-2):i.confidence>=.5&&(o=Math.max(0,o-1)),n.push({stateIdx:s,hash:i.hash,prefix:t,isGhost:!1,latitude:i.latitude,longitude:i.longitude,priorCost:o,disambiguationConfidence:i.confidence}),s++}if(o){const o=function(t){if(0===t.length)return 3;const e=Math.max(...t.map(t=>t.confidence));return e>=.6?12:e>=.3?8:5}(e);n.push({stateIdx:s,hash:null,prefix:t,isGhost:!0,priorCost:o,disambiguationConfidence:0})}return n}function y(t,e,o){var n,s;const i=o.minEdgeObservationsForHistory??3;if(t.isGhost||e.isGhost)return 8;const r=(c={latitude:t.latitude,longitude:t.longitude},u={latitude:e.latitude,longitude:e.longitude},void 0===c.latitude||void 0===c.longitude||0===c.latitude&&0===c.longitude||void 0===u.latitude||void 0===u.longitude||0===u.latitude&&0===u.longitude?3:function(t,e,o,n){const s=g(t,e,o,n);if(s>150)return 1/0;if(s<.1)return.01;const i=function(t){if(t<=0)return 0;const e=1e3*t;return e*e/50968e3}(s);var r,a;const c=(r=s,1/(1+Math.exp(.15*(r-60)))*(a=i,1/(1+Math.exp(.5*(a-40)))));return c<1e-10?1e3:-Math.log(c)}(c.latitude,c.longitude,u.latitude,u.longitude)),a=(f=t.hash)<(l=e.hash)?`${f}-${l}`:`${l}-${f}`;var c,u,f,l;const h=(null==(n=o.edgeHistory)?void 0:n.edgeCounts.get(a))??0,d=(null==(s=o.edgeHistory)?void 0:s.edgeConfidence.get(a))??0,p=Math.sqrt(t.disambiguationConfidence*e.disambiguationConfidence);return function(t,e,o){if(o>=.8&&e>0){const t=Math.log(1+Math.min(e,50)/5);return Math.max(.01,.5-t)}if(o>=.5&&e>0){const o=Math.log(1+e/10);return.3*t+.7*Math.max(.1,t-o)}if(e>0){const o=Math.log(1+e/20);return.7*t+.3*Math.max(.1,t-o)}return t}(r,h,h>=i?Math.max(p,d):p)}function C(t,e,o={}){const n=o.enableGhostNodes??!0;if(0===e.length)return{nodes:[],totalCost:0,confidence:1,hasGhostNodes:!1,ghostPrefixes:[],originalPrefixes:[],usedObservationOverride:!1};const s=e.length,i=[];for(let g=0;g<s;g++){const o=e[g].toUpperCase(),s=m(o,t.get(o)??[],n);if(0===s.length)return v(e);i.push(s)}const r=[];r[0]=i[0].map(t=>({cost:t.priorCost,prevStateIdx:null,state:t}));let a=!1;for(let g=1;g<s;g++){const t=i[g],e=r[g-1];r[g]=t.map(t=>{let n=1/0,s=null;for(let i=0;i<e.length;i++){const r=e[i],c=r.state;if(r.cost===1/0)continue;const u=y(c,t,o);if(t.isGhost||c.isGhost||Math.sqrt(c.disambiguationConfidence*t.disambiguationConfidence)>=(o.observationOverrideThreshold??.8)&&(a=!0),u===1/0)continue;const f=r.cost+u+t.priorCost;f<n&&(n=f,s=i)}return{cost:n,prevStateIdx:s,state:t}})}const c=r[s-1];let u=1/0,f=0;for(let g=0;g<c.length;g++)c[g].cost<u&&(u=c[g].cost,f=g);if(u===1/0)return v(e);const l=[],h=[];let d=f;for(let g=s-1;g>=0;g--){const t=r[g][d],e=t.state;if(e.isGhost){const t={type:"ghost",prefix:e.prefix};l.unshift(t),h.unshift(e.prefix)}else{const t={type:"known",hash:e.hash,prefix:e.prefix,confidence:e.disambiguationConfidence,latitude:e.latitude,longitude:e.longitude};l.unshift(t)}g>0&&null!==t.prevStateIdx&&(d=t.prevStateIdx)}var p;return{nodes:l,totalCost:u,confidence:(p=s>0?u/s:u)===1/0?0:Math.exp(-p),hasGhostNodes:h.length>0,ghostPrefixes:h,originalPrefixes:e,usedObservationOverride:a}}function v(t){return{nodes:t.map(t=>({type:"ghost",prefix:t.toUpperCase()})),totalCost:1/0,confidence:0,hasGhostNodes:!0,ghostPrefixes:t.map(t=>t.toUpperCase()),originalPrefixes:t,usedObservationOverride:!1}}function b(t,e,o){if(!t.hasGhostNodes)return[];const n=[];for(let s=0;s<t.nodes.length;s++){const i=t.nodes[s];if("ghost"!==i.type)continue;let r=null,a=null;for(let e=s-1;e>=0;e--)if("known"===t.nodes[e].type){r=t.nodes[e];break}for(let e=s+1;e<t.nodes.length;e++)if("known"===t.nodes[e].type){a=t.nodes[e];break}n.push({prefix:i.prefix,beforeNodeHash:(null==r?void 0:r.hash)??null,afterNodeHash:(null==a?void 0:a.hash)??null,beforeLocation:void 0!==(null==r?void 0:r.latitude)&&void 0!==(null==r?void 0:r.longitude)?{lat:r.latitude,lon:r.longitude}:void 0,afterLocation:void 0!==(null==a?void 0:a.latitude)&&void 0!==(null==a?void 0:a.longitude)?{lat:a.latitude,lon:a.longitude}:void 0,timestamp:e,packetHash:o})}return n}function S(t){const e=new Map,o=new Map;for(const[n,s]of t)e.set(n,s.count),o.set(n,s.count>0?s.confidenceSum/s.count:0);return{edgeCounts:e,edgeConfidence:o}}const M=6048e5;function w(t,e){if(!t||t<=0)return.1;const o=(e-1e3*t)/36e5;return o<0?1:Math.exp(-o/168)}function x(t,e,o){const n=new Map,s=[];let i,r=1/0,a=0;for(const h of e)if(h.beforeNodeHash&&n.set(h.beforeNodeHash,(n.get(h.beforeNodeHash)??0)+1),h.afterNodeHash&&n.set(h.afterNodeHash,(n.get(h.afterNodeHash)??0)+1),r=Math.min(r,h.timestamp),a=Math.max(a,h.timestamp),h.beforeLocation&&h.afterLocation){const t=(h.beforeLocation.lat+h.afterLocation.lat)/2,e=(h.beforeLocation.lon+h.afterLocation.lon)/2,n=o-1e3*h.timestamp,i=n<M?1-n/M*.5:.5;s.push({lat:t,lon:e,weight:i})}else if(h.beforeLocation||h.afterLocation){const t=h.beforeLocation??h.afterLocation,e=o-1e3*h.timestamp,n=.5*(e<M?1-e/M*.5:.5);s.push({lat:t.lat,lon:t.lon,weight:n})}if(s.length>0){const t=s.reduce((t,e)=>t+e.weight,0),e=s.reduce((t,e)=>t+e.lat*e.weight,0)/t,o=s.reduce((t,e)=>t+e.lon*e.weight,0)/t,n=s.map(t=>g(e,o,t.lat,t.lon)),r=n.reduce((t,e)=>t+e,0)/n.length,a=n.reduce((t,e)=>t+(e-r)**2,0)/n.length,c=Math.sqrt(a);i={lat:e,lon:o,uncertaintyM:1e3*c}}const c=.2*e.length,u=new Set;for(const[h,d]of n)d>=c&&u.add(h);const f=function(t,e,o,n,s){const i=s-1e3*n;return Math.min(.4,t/30*.4)+Math.min(.3,e/4*.3)+(o<1/0?Math.max(0,.2*(1-o/1e4)):0)+(i<M?.1*(1-i/M):0)}(e.length,u.size,(null==i?void 0:i.uncertaintyM)??1/0,a,o),l=e.length>=10&&u.size>=2&&(void 0===i||i.uncertaintyM<1e4)&&f>=.3;return{prefix:t,observations:e,observationCount:e.length,estimatedLocation:i,confidence:f,commonNeighbors:u,firstSeen:r,lastSeen:a,isLikelyReal:l}}function P(t,e){return`${e}:${t.join(">")}`}function k(t,e){return`${t}→${e}`}function H(t){const e=t.route??t.route_type;return o(e)?"flood":n(e)?"direct":"unknown"}function E(t,e){return t.toUpperCase()===(e.startsWith("0x")?e.slice(2,4).toUpperCase():e.slice(0,2).toUpperCase())}function _(t,e){return[t,e].sort().join("-")}function R(g,m,y,v=.4,M,R,D,L){const A=[...g].sort((t,e)=>(t.timestamp??0)-(e.timestamp??0)),N=new Map;for(const t of A){if(!t.packet_hash)continue;const e=N.get(t.packet_hash);e?e.push(t):N.set(t.packet_hash,[t])}let j=0,O=0,$=0;const U=new Map;for(const[,t]of N){if(t.length<2)continue;j++;const e=new Map,o=new Set;for(const n of t){const t=n.original_path??n.forwarded_path;if(!t||!Array.isArray(t)||0===t.length)continue;const s=t.map(t=>String(t).toUpperCase()).join("-");e.has(s)||(e.set(s,t.map(t=>String(t).toUpperCase())),O++);const i=String(t[t.length-1]).toUpperCase();o.add(i)}if(o.size>=2){const t=Array.from(o);for(let e=0;e<t.length;e++)for(let o=e+1;o<t.length;o++){const n=t[e]<t[o]?`${t[e]}-${t[o]}`:`${t[o]}-${t[e]}`,s=U.get(n);s?(s.count++,s.confidence=Math.min(.95,s.confidence+.05)):U.set(n,{count:1,confidence:.6})}}}const G=function(t,e,o,n,a){const u=new Map,d=function(t){const e={};for(const[o,n]of Object.entries(t))f(n)&&(e[o]=n);return e}(e),p=new Map,g=void 0!==n&&void 0!==a&&(0!==n||0!==a);if(o){const t=s(o),e={hash:o,prefix:t,positionCounts:new Array(5).fill(0),totalAppearances:0,typicalPosition:0,positionConsistency:0,adjacentPrefixCounts:new Map,totalAdjacentObservations:0,latitude:n,longitude:a,distanceToLocal:0,srcGeoEvidenceScore:0,srcGeoEvidenceCount:0,lastSeenTimestamp:Math.floor(Date.now()/1e3),recencyScore:1,positionScore:0,cooccurrenceScore:0,geographicScore:1,combinedScore:0};p.set(t,[e])}for(const[i,r]of Object.entries(d)){const t=s(i),e=r.last_seen??0;if(h(e))continue;let o;const u=!0===r.zero_hop;g&&r.latitude&&r.longitude&&(0!==r.latitude||0!==r.longitude)&&(o=c(n,a,r.latitude,r.longitude));let f=.2;void 0!==o?f=o<500?1:o<2e3?.8:o<5e3?.6:o<1e4?.4:o<2e4?.2:.1:r.latitude&&r.longitude&&(f=.5),u&&(f=Math.max(f,.95));const d=l(e),m={hash:i,prefix:t,positionCounts:new Array(5).fill(0),totalAppearances:0,typicalPosition:0,positionConsistency:0,adjacentPrefixCounts:new Map,totalAdjacentObservations:0,latitude:r.latitude,longitude:r.longitude,distanceToLocal:o,srcGeoEvidenceScore:0,srcGeoEvidenceCount:0,lastSeenTimestamp:e,recencyScore:d,positionScore:0,cooccurrenceScore:0,geographicScore:f,combinedScore:0},y=p.get(t)||[];y.push(m),p.set(t,y)}for(const s of t){const t=i(s,o);if(!t||0===t.effectiveLength)continue;const n=t.effective,a=s.src_hash,u=a?e[a]:void 0,f=(null==u?void 0:u.latitude)&&(null==u?void 0:u.longitude)&&(0!==u.latitude||0!==u.longitude);for(let e=0;e<n.length;e++){const o=n[e],s=p.get(o);if(!s)continue;const i=r(e,t.effectiveLength),a=Math.min(i-1,4);for(const t of s){if(t.positionCounts[a]++,t.totalAppearances++,1===i&&s.length>1&&f&&t.latitude&&t.longitude){const e=c(u.latitude,u.longitude,t.latitude,t.longitude);let o=0;o=e<500?1:e<2e3?.8:e<5e3?.5:e<1e4?.3:.1,void 0!==t.distanceToLocal&&(t.distanceToLocal<500?o*=1.2:t.distanceToLocal<2e3?o*=1:o*=.8),t.srcGeoEvidenceScore+=o,t.srcGeoEvidenceCount++}if(e>0&&s.length>1&&t.latitude&&t.longitude){const o=n[e-1],s=p.get(o);if(s&&s.length>0){let e,o,n=0;if(1===s.length){const t=s[0];t.latitude&&t.longitude&&(e=t.latitude,o=t.longitude,n=1)}else{const t=[...s].sort((t,e)=>e.combinedScore-t.combinedScore),i=t[0],r=t[1];if(i.latitude&&i.longitude&&i.combinedScore>0){const t=r?(i.combinedScore-r.combinedScore)/i.combinedScore:1;n=Math.min(1,t+.3),n>.4&&(e=i.latitude,o=i.longitude)}}if(void 0!==e&&void 0!==o){const s=c(t.latitude,t.longitude,e,o);let i=0;i=s<500?1:s<2e3?.8:s<5e3?.5:s<1e4?.3:.1,i*=n,t.srcGeoEvidenceScore+=i,t.srcGeoEvidenceCount++}}}if(i>1&&s.length>1&&t.latitude&&t.longitude){const o=e+1;if(o<n.length){const e=n[o],s=p.get(e);if(s&&s.length>0){let e,o,n=0;if(1===s.length){const t=s[0];t.latitude&&t.longitude&&(e=t.latitude,o=t.longitude,n=1)}else{const t=[...s].sort((t,e)=>e.combinedScore-t.combinedScore),i=t[0],r=t[1];if(i.latitude&&i.longitude&&i.combinedScore>0){const t=r?(i.combinedScore-r.combinedScore)/i.combinedScore:1;n=Math.min(1,t+.3),n>.4&&(e=i.latitude,o=i.longitude)}}if(void 0!==e&&void 0!==o){const s=c(t.latitude,t.longitude,e,o);let i=0;i=s<500?1:s<2e3?.8:s<5e3?.5:s<1e4?.3:.1,i*=n,t.srcGeoEvidenceScore+=i,t.srcGeoEvidenceCount++}}}}if(e>0){const o=n[e-1];t.adjacentPrefixCounts.set(o,(t.adjacentPrefixCounts.get(o)||0)+1),t.totalAdjacentObservations++}if(e<n.length-1){const o=n[e+1];t.adjacentPrefixCounts.set(o,(t.adjacentPrefixCounts.get(o)||0)+1),t.totalAdjacentObservations++}}}}let m=1,y=1;for(const s of p.values())for(const t of s)m=Math.max(m,t.totalAppearances),y=Math.max(y,t.totalAdjacentObservations);for(const s of p.values())for(const t of s){if(t.totalAppearances>0){let e=0,o=1;for(let s=0;s<5;s++)t.positionCounts[s]>e&&(e=t.positionCounts[s],o=s+1);t.typicalPosition=o,t.positionConsistency=e/t.totalAppearances;const n=t.totalAppearances/m;t.positionScore=.6*t.positionConsistency+.4*n}if(t.totalAdjacentObservations>0&&(t.cooccurrenceScore=t.totalAdjacentObservations/y),t.combinedScore=.15*t.positionScore+.15*t.cooccurrenceScore+.35*t.geographicScore+.35*t.recencyScore,t.srcGeoEvidenceCount>0){const e=t.srcGeoEvidenceScore/t.srcGeoEvidenceCount*Math.min(t.srcGeoEvidenceCount/50,1)*.3;t.combinedScore+=e}}for(const[s,i]of p){i.sort((t,e)=>e.combinedScore-t.combinedScore);const t=i.length>0?i[0].hash:null;let e=0;if(1===i.length)e=1;else if(i.length>1){const t=i[0].combinedScore,o=i[1].combinedScore;t>0&&(e=Math.min(1,(t-o)/t)),i[0].totalAppearances>2*i[1].totalAppearances&&(e=Math.min(1,e+.2));const n=0,s=i[0].positionCounts[n]||0,r=s+(i[1].positionCounts[n]||0);if(r>=20&&s>=10){const t=s/r;if(t>=.8){const o=.3+1.5*(t-.8);e=Math.min(1,e+o)}}const a=i.reduce((t,e)=>t+e.combinedScore,0);if(a>0){const t=[],o=i.reduce((t,e)=>t+(e.positionCounts[0]||0),0);for(const e of i){const n=o*(e.combinedScore/a);t.push(n)}const n=t[0],s=n+(t[1]||0);if(s>=20&&n>=10){const t=n/s;if(t>=.6){const o=.2+1*(t-.6);e=Math.min(1,e+o)}}}const c=i[0].srcGeoEvidenceScore,u=i[1].srcGeoEvidenceScore;if(i[0].srcGeoEvidenceCount>=10&&c>1.5*u){const t=u>0?c/(c+u):1,o=Math.min(.3,.6*(t-.5));e=Math.min(1,e+o)}}const o=new Map;for(let s=1;s<=5;s++){const t=[...i].sort((t,e)=>{const o=t.positionCounts[s-1]||0;return(e.positionCounts[s-1]||0)-o});if(t.length>0&&t[0].positionCounts[s-1]>0){const e=t[0];let n=1;if(t.length>1){const o=e.positionCounts[s-1],i=o+(t[1].positionCounts[s-1]||0);n=i>0?o/i:0}o.set(s,{hash:e.hash,confidence:n})}}const n={prefix:s,candidates:i,bestMatch:t,confidence:e,isUnambiguous:1===i.length,bestMatchForPosition:o};u.set(s,n)}return u}(A,m,y,M,R),I=function(t,e,o,n,s,a){const f=new Map,l=void 0!==o&&void 0!==n&&(0!==o||0!==n);for(const[i,r]of Object.entries(e)){let t=null,e=.5;l&&r.latitude&&r.longitude&&(0!==r.latitude||0!==r.longitude)&&(t=c(o,n,r.latitude,r.longitude),e=u(t)),r.zero_hop&&(e=Math.max(e,.9)),f.set(i,{hash:i,frequency:0,directForwardCount:0,distanceMeters:t,proximityScore:e,hopPositionCounts:[0,0,0,0,0],avgHopDistance:0,typicalHopPosition:0,hopConsistencyScore:0,frequencyScore:0,combinedScore:0,avgDisambiguationConfidence:0,collisionCount:0,resolutionCount:0})}const h=new Map;for(const c of t){const t=i(c,s);if(t&&t.effectiveLength>=1){const e=t.effective;for(let o=0;o<e.length;o++){const n=e[o],s=r(o,t.effectiveLength);if(a){const t=d(a,n,{position:s,adjacentPrefixes:[...o>0?[e[o-1]]:[],...o<e.length-1?[e[o+1]]:[]],isLastHop:1===s});if(t.hash){const e=f.get(t.hash);if(e){e.frequency++,e.resolutionCount++;const o=h.get(t.hash)||0;h.set(t.hash,o+t.confidence);const i=a.get(n.toUpperCase());i&&!i.isUnambiguous&&e.collisionCount++;const r=Math.min(s-1,4);e.hopPositionCounts[r]++,1===s&&e.directForwardCount++}}}else for(const[t,e]of f)if(E(n,t)){e.frequency++;const t=Math.min(s-1,4);e.hopPositionCounts[t]++,1===s&&e.directForwardCount++}}}if((!t||0===t.effectiveLength)&&c.src_hash){const t=f.get(c.src_hash);if(t){t.frequency++,t.directForwardCount++,t.hopPositionCounts[0]++,t.resolutionCount++;const e=h.get(c.src_hash)||0;h.set(c.src_hash,e+1)}}}let p=0;for(const i of f.values())p=Math.max(p,i.frequency);for(const i of f.values()){let t=0,e=0,o=0,n=1;for(let r=0;r<i.hopPositionCounts.length;r++){const s=i.hopPositionCounts[r],a=r+1;t+=s,e+=s*a,s>o&&(o=s,n=a)}i.avgHopDistance=t>0?e/t:0,i.typicalHopPosition=n,t>0&&o>0&&(i.hopConsistencyScore=o/t),i.frequencyScore=p>0?i.frequency/p:0;const s=h.get(i.hash)||0;i.avgDisambiguationConfidence=i.resolutionCount>0?s/i.resolutionCount:0,i.combinedScore=.3*i.proximityScore+.3*i.hopConsistencyScore+.4*i.frequencyScore}return f}(A,m,M,R,y,G),F=y?s(y):null,T=new Map;for(const[t,e]of I)T.set(t,e.combinedScore);const q=new Map,z=new Map,V=new Map,B=new Map,W=new Map,K=Math.floor(Date.now()/1e3),Z=(t,e,s,i,r,a,c,u)=>{const f=_(t,e),l=q.get(f),[h,d]=t<e?[t,e]:[e,t],p=t===h,g=o(a)||void 0===a,m=n(a),y=(t=>{if(!t||t<=0)return.1;const e=(K-t)/3600;return e<0?1:Math.exp(-e/12)})(c);if(l)l.count++,l.confidenceSum+=s,l.recencySum+=y,l.minHopDistance=Math.min(l.minHopDistance,r),r<l.hopDistanceCounts.length&&l.hopDistanceCounts[r]++,i?l.certainCount++:l.uncertainCount++,p?l.forwardCount++:l.reverseCount++,g?l.floodCount++:m&&l.directCount++,void 0!==u&&u>0&&(l.viterbiConfidenceSum+=u,l.viterbiObservationCount++);else{const t=[0,0,0,0,0,0,0,0,0,0];r<t.length&&t[r]++,q.set(f,{fromHash:h,toHash:d,key:f,count:1,confidenceSum:s,minHopDistance:r,hopDistanceCounts:t,certainCount:i?1:0,uncertainCount:i?0:1,forwardCount:p?1:0,reverseCount:p?0:1,floodCount:g?1:0,directCount:m?1:0,recencySum:y,viterbiConfidenceSum:u??0,viterbiObservationCount:void 0!==u&&u>0?1:0})}},J=function(t){const e=new Map;for(const[o,n]of t){const t=n.candidates.map(t=>({hash:t.hash,prefix:t.prefix,latitude:t.latitude,longitude:t.longitude,confidence:t.combinedScore,recencyScore:t.recencyScore}));e.set(o,t)}return e}(G),X=[];let Y=0,Q=0,tt=0,et=0;const ot=new Set,nt=new Map;let st=0,it=0,rt=0;for(const e of A){const o=i(e,y);if(!o)continue;const n=o.effective,s=o.effectiveLength,c=o.original,u=new Set;if(e.src_hash&&c.length>=1){const t=c[0],o=e.src_hash.toUpperCase();if(o!==t){const n=d(G,o,{position:s+1,adjacentPrefixes:[t]}),i=d(G,t,{position:s,adjacentPrefixes:[o,...c.length>1?[c[1]]:[]]});if(n.hash&&i.hash&&n.hash!==i.hash){const t=Object.keys(m).includes(n.hash),o=n.confidence*i.confidence,r=o>=.6&&t,a=o*(t?1:.8),c=s+1,f=e.route??e.route_type;Z(n.hash,i.hash,a,r,c,f,e.timestamp),u.add(n.hash),u.add(i.hash)}}}const f=4===(e.type??e.payload_type);if(f&&0===s&&e.src_hash&&y){const t=d(G,e.src_hash.toUpperCase(),{position:1,isLastHop:!0});if(t.hash&&t.hash!==y){const o=e.route??e.route_type;Z(t.hash,y,1,!0,0,o,e.timestamp),u.add(t.hash),u.add(y),B.set(t.hash,(B.get(t.hash)||0)+1)}}if(y&&s>=1){const t=s-1,o=n[t];if(f){const t=W.get(o);t?(t.count++,"number"!=typeof e.rssi||isNaN(e.rssi)||(t.rssiSum+=e.rssi,t.rssiCount++),"number"!=typeof e.snr||isNaN(e.snr)||(t.snrSum+=e.snr,t.snrCount++),t.lastSeen=Math.max(t.lastSeen,e.timestamp??0)):W.set(o,{prefix:o,count:1,rssiSum:"number"!=typeof e.rssi||isNaN(e.rssi)?0:e.rssi,rssiCount:"number"!=typeof e.rssi||isNaN(e.rssi)?0:1,snrSum:"number"!=typeof e.snr||isNaN(e.snr)?0:e.snr,snrCount:"number"!=typeof e.snr||isNaN(e.snr)?0:1,lastSeen:e.timestamp??0,resolvedHashes:new Map})}const i=d(G,o,{position:1,adjacentPrefixes:t>0?[n[t-1]]:[],isLastHop:!0});if(f&&i.hash){const t=W.get(o);if(t){const e=t.resolvedHashes.get(i.hash);e?(e.count++,e.confidenceSum+=i.confidence):t.resolvedHashes.set(i.hash,{count:1,confidenceSum:i.confidence})}}if(i.hash&&i.hash!==y){const t=!0,o=i.confidence,n=e.route??e.route_type;Z(i.hash,y,o,t,0,n,e.timestamp),u.add(i.hash),u.add(y),B.set(i.hash,(B.get(i.hash)||0)+1)}}if(s>=2){const o=C(J,n,{edgeHistory:S(q),observationOverrideThreshold:.8,enableGhostNodes:!0,minEdgeObservationsForHistory:3}),i=e.packet_hash,c=e.timestamp??0,f=(c>0?(K-c)/3600:1/0)<=336,l=i&&!ot.has(i);if(l&&f?(ot.add(i),Y++,o.hasGhostNodes&&Q++,o.usedObservationOverride&&tt++,o.totalCost!==1/0&&(et+=o.confidence)):l&&ot.add(i),o.hasGhostNodes&&f){const t=b(o,c,e.packet_hash);X.push(...t)}for(let n=0;n<o.nodes.length-1;n++){const i=o.nodes[n],c=o.nodes[n+1];if(!p(i)||!p(c))continue;const f=i.hash,l=c.hash;if(f===l)continue;const h=i.confidence,d=c.confidence,g=r(n+1,s),m=d>=.9,y=h>=t&&d>=t||m||1===g&&d>=t;u.add(f),u.add(l),n>0&&n<o.nodes.length-1&&V.set(f,(V.get(f)||0)+1);const C=m?d:h*d;!y&&C<v||Z(f,l,C,y,a(g),e.route??e.route_type,e.timestamp,o.confidence)}const h=o.nodes.filter(p);if(h.length>=3)for(let t=0;t<h.length-2;t++){const e=h[t].hash,n=h[t+2].hash,s=h[t+1].hash;if(e===n)continue;const i=e<n?`${e}-${n}`:`${n}-${e}`,r=nt.get(i);if(r)r.count++,r.totalConfidence+=o.confidence,r.intermediates.set(s,(r.intermediates.get(s)||0)+1);else{const t=new Map;t.set(s,1),nt.set(i,{endpointA:e<n?e:n,endpointB:e<n?n:e,intermediates:t,totalConfidence:o.confidence,count:1})}}}else if(1===s){const t=d(G,n[0],{position:1,isLastHop:!0});t.hash&&u.add(t.hash)}for(const t of u)z.set(t,(z.get(t)||0)+1)}for(const e of A){const o=e.type??e.payload_type;if(9!==o&&8!==o)continue;const n=e.original_path??e.forwarded_path;if(!n||!Array.isArray(n)||n.length<2)continue;const s=n.map(t=>String(t).toUpperCase());9===o?it++:rt++;for(let i=0;i<s.length-1;i++){const o=s[i],n=s[i+1];if(o===n)continue;const r=d(G,o,{position:s.length-i,adjacentPrefixes:i>0?[s[i-1]]:[]}),a=d(G,n,{position:s.length-i-1,adjacentPrefixes:[o,...i+2<s.length?[s[i+2]]:[]]});if(!r.hash||!a.hash)continue;if(r.hash===a.hash)continue;const c=r.confidence*a.confidence,u=r.confidence>=t&&a.confidence>=t,f=r.hash===y,l=a.hash===y,h=Object.keys(m).includes(r.hash),p=Object.keys(m).includes(a.hash);let g;g=f||l?0:h||p?1:Math.max(2,Math.min(i+1,5));const C=2;Z(r.hash,a.hash,c,u,g,C,e.timestamp,.8*c),st++,z.set(r.hash,(z.get(r.hash)||0)+1),z.set(a.hash,(z.get(a.hash)||0)+1),i>0&&i<s.length-2&&V.set(r.hash,(V.get(r.hash)||0)+1)}}const at=new Map;let ct=0;for(const[t,e]of z){const o=V.get(t)||0,n=e>0?o/e:0;at.set(t,n),ct=Math.max(ct,n)}if(ct>0)for(const[t,e]of at)at.set(t,e/ct);const ut=new Set,ft=new Set,lt=[...B.values()].reduce((t,e)=>t+e,0);for(const[t,e]of B){if(t===y)continue;const o=lt>0?e/lt:0;if(o>=.1){ut.add(t);const e=at.get(t)||0;at.set(t,Math.max(e,o))}else if(o>=.07){ft.add(t);const e=at.get(t)||0;at.set(t,Math.max(e,o))}}const ht=Array.from(ut),dt=Array.from(ft);for(const t of nt.values()){if(t.count<5)continue;if(t.totalConfidence/t.count<.5)continue;const e=_(t.endpointA,t.endpointB);if(q.has(e)){const o=q.get(e);o.count+=Math.floor(.5*t.count),o.confidenceSum+=.5*t.totalConfidence,o.viterbiConfidenceSum+=t.totalConfidence,o.viterbiObservationCount+=t.count}else{const o=[0,0,0,0,0,0,0,0,0,0];o[2]=t.count,q.set(e,{fromHash:t.endpointA,toHash:t.endpointB,key:e,count:t.count,confidenceSum:.7*t.totalConfidence,minHopDistance:2,hopDistanceCounts:o,certainCount:0,uncertainCount:t.count,forwardCount:Math.floor(t.count/2),reverseCount:Math.ceil(t.count/2),floodCount:t.count,directCount:0,recencySum:.5*t.count,viterbiConfidenceSum:t.totalConfidence,viterbiObservationCount:t.count})}}for(const[e,o]of U){if(o.count<3)continue;if(o.confidence<.6)continue;const[n,s]=e.split("-"),i=d(G,n,{position:1,isLastHop:!0}),r=d(G,s,{position:1,isLastHop:!0});if(!i.hash||!r.hash)continue;if(i.hash===r.hash)continue;const a=_(i.hash,r.hash),c=q.get(a),u=o.confidence*Math.min(i.confidence,r.confidence);if(c)c.count+=o.count,c.confidenceSum+=u*o.count,c.recencySum+=.7*o.count,u>=t?c.certainCount+=Math.floor(.5*o.count):c.uncertainCount+=o.count,$++;else{const e=[0,0,0,0,0,0,0,0,0,0];e[1]=o.count;const[n,s]=i.hash<r.hash?[i.hash,r.hash]:[r.hash,i.hash];q.set(a,{fromHash:n,toHash:s,key:a,count:o.count,confidenceSum:u*o.count,minHopDistance:1,hopDistanceCounts:e,certainCount:u>=t?Math.floor(.3*o.count):0,uncertainCount:o.count,forwardCount:Math.floor(o.count/2),reverseCount:Math.ceil(o.count/2),floodCount:o.count,directCount:0,recencySum:.7*o.count,viterbiConfidenceSum:0,viterbiObservationCount:0}),$++}}const pt=[],gt=[],mt=[];let yt=0,Ct=0;const vt=new Set(ht),bt=new Set;for(const t of q.values()){const e=t.confidenceSum/t.count;yt=Math.max(yt,t.count),Ct=Math.max(Ct,t.certainCount);const o=vt.has(t.fromHash)||vt.has(t.toHash),n=t.certainCount>=5,s=t.forwardCount+t.reverseCount,i=s>0?Math.min(t.forwardCount,t.reverseCount)/Math.max(t.forwardCount,t.reverseCount):0;let r="balanced";i<.7&&s>0&&(r=t.forwardCount>t.reverseCount?"forward":"reverse");const a=t.floodCount+t.directCount>0&&t.directCount>t.floodCount,c=t.count>0?t.recencySum/t.count:0,u={fromHash:t.fromHash,toHash:t.toHash,key:t.key,packetCount:t.count,avgConfidence:e,strength:0,avgRecency:c,hopDistanceFromLocal:t.minHopDistance,isHubConnection:o,isCertain:n,certainCount:t.certainCount,forwardCount:t.forwardCount,reverseCount:t.reverseCount,symmetryRatio:i,dominantDirection:r,floodCount:t.floodCount,directCount:t.directCount,isDirectPathEdge:a};pt.push(u),n&&(gt.push(u),bt.add(t.key))}for(const t of pt)!bt.has(t.key)&&t.packetCount>=2&&mt.push(t);if(L&&L.length>0&&y)for(const t of L){if(t.hash===y)continue;const e=_(y,t.hash),o=pt.find(t=>t.key===e);if(o)o.isZeroHop=!0,o.isCertain=!0,o.avgConfidence=Math.max(o.avgConfidence,.95),bt.has(e)||(gt.push(o),bt.add(e));else{const[o,n]=y<t.hash?[y,t.hash]:[t.hash,y],s={fromHash:o,toHash:n,key:e,packetCount:t.advertCount,avgConfidence:1,strength:1,avgRecency:1,hopDistanceFromLocal:0,isHubConnection:vt.has(t.hash),isCertain:!0,certainCount:t.advertCount,forwardCount:0,reverseCount:t.advertCount,symmetryRatio:0,dominantDirection:"reverse",floodCount:t.advertCount,directCount:0,isDirectPathEdge:!1,isZeroHop:!0,avgRssi:t.avgRssi,avgSnr:t.avgSnr};if(t.lastSeen&&t.lastSeen>0){const e=(K-t.lastSeen)/3600;s.avgRecency=e>=0?Math.exp(-e/12):1}pt.push(s),gt.push(s),bt.add(e)}}for(const t of pt){const e=q.get(t.key),o=e&&e.viterbiObservationCount>0?e.viterbiConfidenceSum/e.viterbiObservationCount:0,n=yt>0?t.packetCount/yt:0;t.strength=.3*n+.3*t.avgConfidence+.25*o+.15*t.avgRecency}pt.sort((t,e)=>e.certainCount-t.certainCount),gt.sort((t,e)=>{const o=t.certainCount+(t.isHubConnection?1e3:0);return e.certainCount+(e.isHubConnection?1e3:0)-o}),mt.sort((t,e)=>t.packetCount-e.packetCount);const St=gt.slice(0,100),Mt=mt.slice(0,100),wt=new Map(pt.map(t=>[t.key,t])),{loops:xt,loopEdgeKeys:Pt}=function(t,e,o=1){if(t.length<3)return{loops:[],loopEdgeKeys:new Set};const n=new Map,s=new Map;for(const u of t)s.set(u.key,u),n.has(u.fromHash)||n.set(u.fromHash,new Set),n.has(u.toHash)||n.set(u.toHash,new Set),n.get(u.fromHash).add(u.toHash),n.get(u.toHash).add(u.fromHash);const i=[],r=new Set,a=new Set;function c(t,e,o){if(t===e)return[t];const s=new Set([t]),i=[{node:t,path:[t]}];for(;i.length>0;){const{node:t,path:r}=i.shift(),a=n.get(t);if(a)for(const n of a)if(_(t,n)!==o){if(n===e)return[...r,n];s.has(n)||(s.add(n),i.push({node:n,path:[...r,n]}))}}return null}for(const u of t){const t=c(u.fromHash,u.toHash,u.key);if(t&&t.length>=2){const n=t,c=[u.key];for(let e=0;e<t.length-1;e++){const o=_(t[e],t[e+1]);c.push(o)}const f=[...n].sort().join(",");if(a.has(f))continue;a.add(f);let l=0,h=1/0;for(const t of c){const e=s.get(t);e&&(l+=e.certainCount,h=Math.min(h,e.certainCount),r.add(t))}const d=c.length>0?l/c.length:0,p=!!e&&n.includes(e),g={id:`loop-${i.length}`,edgeKeys:c,nodes:n,size:c.length,avgCertainCount:d,minCertainCount:h===1/0?0:h,includesLocal:p,strength:o>0?h===1/0?0:h/o:0};i.push(g)}}return i.sort((t,e)=>t.includesLocal!==e.includesLocal?t.includesLocal?-1:1:e.strength-t.strength),{loops:i,loopEdgeKeys:r}}(gt,y,Ct);for(const t of pt)t.isLoopEdge=Pt.has(t.key);const kt=function(t,e){const o=new Map,n=new Map;let s=0;for(const a of t){if(!a.src_hash)continue;const t=a.original_path??a.forwarded_path;if(!t||!Array.isArray(t)||0===t.length)continue;const n=t.map(t=>"string"==typeof t?t.toUpperCase().slice(0,2):String(t).toUpperCase().slice(0,2)),i=e||"unknown",r=a.src_hash,c=P(n,r);let u=o.get(c);u||(u={id:c,hops:n,srcHash:r,dstHash:i,observationCount:0,firstSeen:a.timestamp,lastSeen:a.timestamp,routeType:H(a),hopCount:n.length},o.set(c,u)),u.observationCount++,u.lastSeen=Math.max(u.lastSeen,a.timestamp),u.firstSeen=Math.min(u.firstSeen,a.timestamp),s++,"direct"===H(a)&&"direct"!==u.routeType&&(u.routeType="direct")}const i=Array.from(o.values());for(const a of i){const t=k(a.srcHash,a.dstHash),e=n.get(t)||[];e.push(a),n.set(t,e)}for(const a of n.values())a.sort((t,e)=>e.observationCount-t.observationCount);const r=new Map;for(const[a,c]of n)c.length>0&&r.set(a,c[0]);return{paths:i,byEndpoints:n,canonicalPaths:r,totalObservations:s,uniquePathCount:i.length}}(A,y),Ht=function(t,o,n,s){const i=new Map;if(0===t.length||0===n.length)return i;const r=t=>{const e=.2*Math.round(t/.2);return Math.max(.4,Math.min(2,e))},a=t=>Math.floor(5*t),c=new Set;for(const e of t)c.add(e.fromHash),c.add(e.toHash);const u=n.map(t=>t.timestamp).filter(t=>void 0!==t&&t>0).sort((t,e)=>t-e),f=u.length>=2?(u[u.length-1]-u[0])/60:1,l=new Map;for(const e of t)l.has(e.fromHash)||l.set(e.fromHash,[]),l.has(e.toHash)||l.set(e.toHash,[]),l.get(e.fromHash).push(e),l.get(e.toHash).push(e);const h=new Set;for(const e of t)e.isLoopEdge&&h.add(e.key);const d=new Set;for(const[,e]of s.canonicalPaths)for(const t of e.hops)d.add(t.toUpperCase());const p=new Map;for(const e of c){const t=l.get(e)||[];if(0===t.length)continue;const o=e.startsWith("0x")?e.slice(2,4).toUpperCase():e.slice(0,2).toUpperCase(),n=new Set;let i=0,r=0,a=0,c=0,u=0,d=0,g=0;for(const s of t){const t=s.fromHash===e?s.toHash:s.fromHash;n.add(t),i+=s.packetCount,r+=s.certainCount,a=Math.max(a,s.certainCount),c+=s.symmetryRatio,u+=s.floodCount,s.isDirectPathEdge&&d++,h.has(s.key)&&g++}const m=n.size,y=t.length>0?c/t.length:0,C=t.length>0?r/t.length:0,v=s.paths.filter(t=>t.hops.some(t=>t.toUpperCase()===o)),b=v.length;let S=0;for(const[,e]of s.canonicalPaths)e.hops.some(t=>t.toUpperCase()===o)&&S++;const M=v.length>0?v.reduce((t,e)=>t+e.hopCount,0)/v.length:0;p.set(e,{neighborCount:m,totalEdgePackets:i,maxEdgeCertainCount:a,avgEdgeCertainCount:C,avgSymmetry:y,forwardingBurden:0,floodForwardRatio:i>0?u/i:0,pathCount:b,canonicalPathCount:S,avgPathLength:M,loopParticipation:t.length>0?g/t.length:0,isInLoop:g>0,edgeDensity:0,trafficRate:f>0?i/f:0,directPathEdgeRatio:t.length>0?d/t.length:0})}const g=[],m=[],y=[],C=[];for(const[,x]of p)x.totalEdgePackets>=e&&(g.push(x.totalEdgePackets),m.push(x.neighborCount),y.push(x.pathCount),C.push(x.trafficRate));g.sort((t,e)=>t-e),m.sort((t,e)=>t-e),y.sort((t,e)=>t-e),C.sort((t,e)=>t-e);const v=(t,e)=>{if(0===t.length)return.5;const o=t.findIndex(t=>t>=e);return-1===o?1:0===o?0:o/t.length},b=m.length>0?Math.max(...m):1;for(const[,e]of p)e.forwardingBurden=v(g,e.totalEdgePackets),e.edgeDensity=b>0?e.neighborCount/b:0;const S=new Map;for(const x of c){const t=p.get(x);if(!t||t.totalEdgePackets<e)continue;const o=x.startsWith("0x")?x.slice(2,4).toUpperCase():x.slice(0,2).toUpperCase(),i=t.forwardingBurden,r=v(m,t.neighborCount),a=.3*t.avgSymmetry,c=Math.min(1,r+a),u=.6*(s.canonicalPaths.size>0?t.canonicalPathCount/s.canonicalPaths.size:0)+.4*v(y,t.pathCount),f=t.loopParticipation,l=.3*i+.3*c+.2*u+.2*f;let h,d=.4+1.6*l;d=Math.max(.4,Math.min(2,d)),h=l>=.7&&t.neighborCount>=4?"backbone":t.neighborCount>=4?"hub":l>=.3&&t.neighborCount>=2?"relay":"edge";const g=s.paths.filter(t=>t.hops.some(t=>t.toUpperCase()===o)).flatMap(t=>{const e=t.hops.findIndex(t=>t.toUpperCase()===o);return e>=0?[e+1]:[]}),C=g.length>0?g.reduce((t,e)=>t+e,0)/g.length:0;let b=0;g.length>1&&(b=g.reduce((t,e)=>t+Math.pow(e-C,2),0)/g.length);const M=.3*Math.min(t.avgEdgeCertainCount/10,1)+.3*Math.min(n.length/1e3,1)+.4*t.avgSymmetry;let w;w=n.length<e?"insufficient":n.length<500?"low":n.length<1e3?"medium":"high",S.set(x,{compositeScore:l,rawFloodDelay:d,networkRole:h,collisionRisk:c,floodParticipationRate:t.floodForwardRatio,avgPathPosition:C,pathPositionVariance:b,pathDiversity:t.pathCount,trafficIntensity:t.trafficRate,confidence:M,observationSymmetry:t.avgSymmetry,dataConfidence:w,factors:{forwarding:i,collision:c,criticality:u,redundancy:f}})}const M=new Map;for(const[e,x]of S){const t=a(r(x.rawFloodDelay));M.has(t)||M.set(t,[]),M.get(t).push(e)}const w=new Map;for(const[,e]of M){if(e.length<=1){if(1===e.length){const t=e[0],o=S.get(t);w.set(t,r(o.rawFloodDelay))}continue}const t=[...e].sort((t,e)=>{const o=S.get(t),n=S.get(e);return o.compositeScore-n.compositeScore});for(let e=0;e<t.length;e++){const o=t[e],n=S.get(o),s=e%3*.2;w.set(o,r(n.rawFloodDelay+s))}}for(const x of c){const t=p.get(x);if(!t||t.totalEdgePackets<e){i.set(x,{floodFactor:0,directFactor:0,floodSlots:0,directSlots:0,floodDelaySec:0,directDelaySec:0,txDelayFactor:0,directTxDelayFactor:0,trafficIntensity:0,directNeighborCount:(null==t?void 0:t.neighborCount)??0,collisionRisk:0,confidence:0,insufficientData:!0,networkRole:"edge",rationale:"Insufficient data (<100 packets observed)",adjustment:"stable",avgPathPosition:0,pathPositionVariance:0,floodParticipationRate:0,pathDiversity:0,positionDelayMs:0,observationSymmetry:(null==t?void 0:t.avgSymmetry)??0,dataConfidence:"insufficient"});continue}const o=S.get(x),n=w.get(x)??r(o.rawFloodDelay),s=r(.7*n),c=a(n),u=a(s);let f,l={backbone:`Backbone: ${t.neighborCount} neighbors, ${Math.round(100*t.avgSymmetry)}% symmetric`,hub:`Hub: ${t.neighborCount} neighbors`,relay:`Relay: ${Math.round(100*t.avgSymmetry)}% symmetric traffic`,edge:"Edge node"}[o.networkRole];o.observationSymmetry>=.6?l+=". High bidirectional visibility (+1 slot)":o.observationSymmetry<.3&&(l+=". ⚠️ Low symmetry (possible observer bias)"),"low"===o.dataConfidence&&(l+=". Limited data"),f=c>a(1)?"increase":c<a(1)?"decrease":"stable";const h=0;i.set(x,{floodFactor:n,directFactor:s,floodSlots:c,directSlots:u,floodDelaySec:n,directDelaySec:s,txDelayFactor:n,directTxDelayFactor:s,trafficIntensity:Math.round(10*o.trafficIntensity)/10,directNeighborCount:t.neighborCount,collisionRisk:Math.round(100*o.collisionRisk)/100,confidence:o.confidence,insufficientData:!1,networkRole:o.networkRole,rationale:l,adjustment:f,avgPathPosition:Math.round(10*o.avgPathPosition)/10,pathPositionVariance:Math.round(100*o.pathPositionVariance)/100,floodParticipationRate:Math.round(100*o.floodParticipationRate)/100,pathDiversity:o.pathDiversity,positionDelayMs:h,observationSymmetry:Math.round(100*o.observationSymmetry)/100,dataConfidence:o.dataConfidence})}return i}(pt,0,A,kt),Et=function(t,e){const o=new Map,n=new Map(e.map(t=>[t.key,t]));for(const s of e)o.set(s.key,0);if(0===t.paths.length)return o;for(const r of t.paths)for(let t=0;t<r.hops.length-1;t++){const n=r.hops[t],i=r.hops[t+1];for(const t of e){const e=s(t.fromHash),a=s(t.toHash);if(e===n&&a===i||e===i&&a===n){const e=o.get(t.key)||0;o.set(t.key,e+r.observationCount);break}}}const i=Math.max(...o.values(),1);for(const[s,r]of o)o.set(s,r/i);for(const[s,r]of o){const t=n.get(s);if(t){const e=.5+.5*t.symmetryRatio;o.set(s,r*e)}}return o}(kt,pt),_t=function(t,e=3,o=.3){return[...t.entries()].filter(([,t])=>t>=o).sort((t,e)=>e[1]-t[1]).slice(0,e).map(([t])=>t)}(Et,3,.3),{nodeMobility:Rt,mobileNodes:Dt}=function(t,e){const o=new Map,n=[];if(0===t.paths.length)return{nodeMobility:o,mobileNodes:n};const s=36e5,i=t.paths.map(t=>t.lastSeen).sort((t,e)=>t-e),r=i[0],a=i[i.length-1],c=Math.ceil((a-r)/s)||1,u=new Map;for(const f of t.paths){const t=Math.floor((f.lastSeen-r)/s);for(const o of f.hops){let n=o;for(const[t]of Object.entries(e))if((t.startsWith("0x")?t.slice(2,4).toUpperCase():t.slice(0,2).toUpperCase())===o.toUpperCase()){n=t;break}let s=u.get(n);s||(s={paths:new Set,firstSeen:f.firstSeen,lastSeen:f.lastSeen,windowPresence:new Set},u.set(n,s)),s.paths.add(f.id),s.firstSeen=Math.min(s.firstSeen,f.firstSeen),s.lastSeen=Math.max(s.lastSeen,f.lastSeen),s.windowPresence.add(t)}}for(const[f,l]of u){const t=l.paths.size,e=l.lastSeen-l.firstSeen,s=e>0?e/36e5:0,i=c>0?l.windowPresence.size/c:1,r=(1-i)*(1-.5*Math.min(t/10,1)),a=r>.3,u={hash:f,pathVolatility:r,pathDiversity:t,avgPathLifespanHours:s,isMobile:a,lastSeen:l.lastSeen,activeWindowRatio:i};o.set(f,u),a&&n.push(f)}return n.sort((t,e)=>{var n,s;const i=(null==(n=o.get(t))?void 0:n.pathVolatility)??0;return((null==(s=o.get(e))?void 0:s.pathVolatility)??0)-i}),{nodeMobility:o,mobileNodes:n}}(kt,m),Lt=function(t,e,o,n=20){const i=[];if(0===t.paths.length)return i;const r=new Map;for(const l of e){const t=s(l.fromHash),e=s(l.toHash);r.set(`${t}>${e}`,l),r.set(`${e}>${t}`,l)}const a=new Set;for(const l of o)a.add(s(l));const c=new Map;for(const s of t.paths){if(0===s.hops.length)continue;const t=s.hops[s.hops.length-1],e=c.get(t)||[];e.push(s.id),c.set(t,e)}const u=[...t.paths].sort((t,e)=>e.observationCount-t.observationCount),f=Date.now();for(const s of u.slice(0,n)){if(s.hops.length<2)continue;let t=0,e=1/0,o=null,n=0,u=!1;for(let i=0;i<s.hops.length-1;i++){const c=s.hops[i],f=s.hops[i+1],l=`${c}>${f}`,h=r.get(l);if(h){const s=h.packetCount>0?h.certainCount/h.packetCount:0;t+=s,n++,s<e&&(e=s,o=h.key)}else t+=.1,n++,.1<e&&(e=.1,o=_(c,f));(a.has(c)||a.has(f))&&(u=!0)}const l=n>0?t/n:0,h=e===1/0?0:e,d=(f-s.lastSeen)/36e5,p=Math.exp(-d/24),g=s.observationCount>10&&d<12?.5+.5*(1-d/12):d>48?-.5:0,m=s.hops[s.hops.length-1],y=c.get(m)||[],C=Math.max(0,y.length-1),v="direct"===s.routeType?20:30,b=s.hops.length*v,S=.4*l,M=.3*p,w=(g+1)/2*.15,x=.15*Math.min(C/3,1),P=Math.round(100*(S+M+w+x))/100;i.push({pathKey:s.id,hops:[...s.hops],healthScore:P,weakestLinkKey:o,weakestLinkConfidence:Math.round(100*h)/100,avgEdgeCertainty:Math.round(100*l)/100,observationTrend:Math.round(100*g)/100,alternatePathsCount:C,estimatedLatencyMs:b,observationCount:s.observationCount,routeType:"unknown"===s.routeType?"mixed":s.routeType,lastSeen:s.lastSeen,involvesHub:u})}return i.sort((t,e)=>e.healthScore-t.healthScore),i}(kt,pt,ht,20),At=[];for(const t of W.values()){let e=null,o=0,n=0;for(const[s,i]of t.resolvedHashes){if(s===y)continue;const t=i.count>0?i.confidenceSum/i.count:0,r=i.count*t;r>o&&(o=r,e=s,n=t)}e&&At.push({hash:e,prefix:t.prefix,count:t.count,confidence:n,avgRssi:t.rssiCount>0?t.rssiSum/t.rssiCount:null,avgSnr:t.snrCount>0?t.snrSum/t.snrCount:null,lastSeen:t.lastSeen})}At.sort((t,e)=>e.count-t.count);let Nt=0,jt=0;const Ot=[],$t=[];let Ut=0;for(const[t,e]of G){Nt+=e.confidence;const o=e.candidates.length;if(!e.isUnambiguous){jt++;const n=e.candidates.map(t=>t.hash);$t.push({prefix:t,candidateCount:o,candidateHashes:n}),e.confidence<.5&&Ot.push(t)}for(const e of I.values())if(e.hash.toUpperCase().startsWith(t)||e.hash.slice(2).toUpperCase().startsWith(t)){Ut+=e.resolutionCount;break}}$t.sort((t,e)=>e.candidateCount-t.candidateCount);const Gt=$t.slice(0,5),It={totalPrefixes:G.size,unambiguousPrefixes:G.size-jt,collisionPrefixes:jt,collisionRate:G.size>0?Math.round(jt/G.size*1e3)/10:0,avgConfidence:G.size>0?Math.round(Nt/G.size*1e3)/1e3:0,lowConfidencePrefixes:Ot,highCollisionPrefixes:Gt,totalResolutions:Ut},Ft=function(t,e){const o=e??Date.now(),n=new Map;for(const i of t){const t=i.prefix.toUpperCase(),e=w(i.timestamp,o),s=n.get(t);s?(s.observations.push(i),s.weightedCount+=e):n.set(t,{observations:[i],weightedCount:e})}const s=[];for(const[i,r]of n){const t=r.observations.length>=10,e=r.weightedCount>=5;if(!t&&!e)continue;const n=x(i,r.observations,o);n&&s.push(n)}return s.sort((t,e)=>e.confidence-t.confidence),s}(X,1e3*K),Tt=Y-Q;return{edges:pt,validatedEdges:St,weakEdges:Mt,certainEdges:St,uncertainEdges:[],edgeMap:wt,maxPacketCount:yt,maxCertainCount:Ct,neighborAffinity:T,fullAffinity:I,localPrefix:F,centrality:at,hubNodes:ht,gatewayNodes:dt,loops:xt,loopEdgeKeys:Pt,txDelayRecommendations:Ht,pathRegistry:kt,edgeBetweenness:Et,backboneEdges:_t,nodeMobility:Rt,mobileNodes:Dt,pathHealth:Lt,lastHopNeighbors:At,disambiguationStats:It,discoveredNodes:Ft,viterbiStats:{totalPaths:Y,pathsWithGhosts:Q,observationOverrideCount:tt,avgPathConfidence:Tt>0?et/Tt:0,avgPathCost:0,tracePacketsProcessed:it,pathPacketsProcessed:rt,distantEdgesDiscovered:st,duplicateGroupsFound:j,duplicatePathsUnique:O,echolocationEdgesInferred:$}}}var D,L,A={exports:{}},N={};L||(L=1,A.exports=function(){if(D)return N;D=1;var t=Symbol.for("react.element"),e=Symbol.for("react.portal"),o=Symbol.for("react.fragment"),n=Symbol.for("react.strict_mode"),s=Symbol.for("react.profiler"),i=Symbol.for("react.provider"),r=Symbol.for("react.context"),a=Symbol.for("react.forward_ref"),c=Symbol.for("react.suspense"),u=Symbol.for("react.memo"),f=Symbol.for("react.lazy"),l=Symbol.iterator,h={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},d=Object.assign,p={};function g(t,e,o){this.props=t,this.context=e,this.refs=p,this.updater=o||h}function m(){}function y(t,e,o){this.props=t,this.context=e,this.refs=p,this.updater=o||h}g.prototype.isReactComponent={},g.prototype.setState=function(t,e){if("object"!=typeof t&&"function"!=typeof t&&null!=t)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,t,e,"setState")},g.prototype.forceUpdate=function(t){this.updater.enqueueForceUpdate(this,t,"forceUpdate")},m.prototype=g.prototype;var C=y.prototype=new m;C.constructor=y,d(C,g.prototype),C.isPureReactComponent=!0;var v=Array.isArray,b=Object.prototype.hasOwnProperty,S={current:null},M={key:!0,ref:!0,__self:!0,__source:!0};function w(e,o,n){var s,i={},r=null,a=null;if(null!=o)for(s in void 0!==o.ref&&(a=o.ref),void 0!==o.key&&(r=""+o.key),o)b.call(o,s)&&!M.hasOwnProperty(s)&&(i[s]=o[s]);var c=arguments.length-2;if(1===c)i.children=n;else if(1<c){for(var u=Array(c),f=0;f<c;f++)u[f]=arguments[f+2];i.children=u}if(e&&e.defaultProps)for(s in c=e.defaultProps)void 0===i[s]&&(i[s]=c[s]);return{$$typeof:t,type:e,key:r,ref:a,props:i,_owner:S.current}}function x(e){return"object"==typeof e&&null!==e&&e.$$typeof===t}var P=/\/+/g;function k(t,e){return"object"==typeof t&&null!==t&&null!=t.key?function(t){var e={"=":"=0",":":"=2"};return"$"+t.replace(/[=:]/g,function(t){return e[t]})}(""+t.key):e.toString(36)}function H(o,n,s,i,r){var a=typeof o;"undefined"!==a&&"boolean"!==a||(o=null);var c=!1;if(null===o)c=!0;else switch(a){case"string":case"number":c=!0;break;case"object":switch(o.$$typeof){case t:case e:c=!0}}if(c)return r=r(c=o),o=""===i?"."+k(c,0):i,v(r)?(s="",null!=o&&(s=o.replace(P,"$&/")+"/"),H(r,n,s,"",function(t){return t})):null!=r&&(x(r)&&(r=function(e,o){return{$$typeof:t,type:e.type,key:o,ref:e.ref,props:e.props,_owner:e._owner}}(r,s+(!r.key||c&&c.key===r.key?"":(""+r.key).replace(P,"$&/")+"/")+o)),n.push(r)),1;if(c=0,i=""===i?".":i+":",v(o))for(var u=0;u<o.length;u++){var f=i+k(a=o[u],u);c+=H(a,n,s,f,r)}else if(f=function(t){return null===t||"object"!=typeof t?null:"function"==typeof(t=l&&t[l]||t["@@iterator"])?t:null}(o),"function"==typeof f)for(o=f.call(o),u=0;!(a=o.next()).done;)c+=H(a=a.value,n,s,f=i+k(a,u++),r);else if("object"===a)throw n=String(o),Error("Objects are not valid as a React child (found: "+("[object Object]"===n?"object with keys {"+Object.keys(o).join(", ")+"}":n)+"). If you meant to render a collection of children, use an array instead.");return c}function E(t,e,o){if(null==t)return t;var n=[],s=0;return H(t,n,"","",function(t){return e.call(o,t,s++)}),n}function _(t){if(-1===t._status){var e=t._result;(e=e()).then(function(e){0!==t._status&&-1!==t._status||(t._status=1,t._result=e)},function(e){0!==t._status&&-1!==t._status||(t._status=2,t._result=e)}),-1===t._status&&(t._status=0,t._result=e)}if(1===t._status)return t._result.default;throw t._result}var R={current:null},L={transition:null},A={ReactCurrentDispatcher:R,ReactCurrentBatchConfig:L,ReactCurrentOwner:S};function j(){throw Error("act(...) is not supported in production builds of React.")}return N.Children={map:E,forEach:function(t,e,o){E(t,function(){e.apply(this,arguments)},o)},count:function(t){var e=0;return E(t,function(){e++}),e},toArray:function(t){return E(t,function(t){return t})||[]},only:function(t){if(!x(t))throw Error("React.Children.only expected to receive a single React element child.");return t}},N.Component=g,N.Fragment=o,N.Profiler=s,N.PureComponent=y,N.StrictMode=n,N.Suspense=c,N.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=A,N.act=j,N.cloneElement=function(e,o,n){if(null==e)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+e+".");var s=d({},e.props),i=e.key,r=e.ref,a=e._owner;if(null!=o){if(void 0!==o.ref&&(r=o.ref,a=S.current),void 0!==o.key&&(i=""+o.key),e.type&&e.type.defaultProps)var c=e.type.defaultProps;for(u in o)b.call(o,u)&&!M.hasOwnProperty(u)&&(s[u]=void 0===o[u]&&void 0!==c?c[u]:o[u])}var u=arguments.length-2;if(1===u)s.children=n;else if(1<u){c=Array(u);for(var f=0;f<u;f++)c[f]=arguments[f+2];s.children=c}return{$$typeof:t,type:e.type,key:i,ref:r,props:s,_owner:a}},N.createContext=function(t){return(t={$$typeof:r,_currentValue:t,_currentValue2:t,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null}).Provider={$$typeof:i,_context:t},t.Consumer=t},N.createElement=w,N.createFactory=function(t){var e=w.bind(null,t);return e.type=t,e},N.createRef=function(){return{current:null}},N.forwardRef=function(t){return{$$typeof:a,render:t}},N.isValidElement=x,N.lazy=function(t){return{$$typeof:f,_payload:{_status:-1,_result:t},_init:_}},N.memo=function(t,e){return{$$typeof:u,type:t,compare:void 0===e?null:e}},N.startTransition=function(t){var e=L.transition;L.transition={};try{t()}finally{L.transition=e}},N.unstable_act=j,N.useCallback=function(t,e){return R.current.useCallback(t,e)},N.useContext=function(t){return R.current.useContext(t)},N.useDebugValue=function(){},N.useDeferredValue=function(t){return R.current.useDeferredValue(t)},N.useEffect=function(t,e){return R.current.useEffect(t,e)},N.useId=function(){return R.current.useId()},N.useImperativeHandle=function(t,e,o){return R.current.useImperativeHandle(t,e,o)},N.useInsertionEffect=function(t,e){return R.current.useInsertionEffect(t,e)},N.useLayoutEffect=function(t,e){return R.current.useLayoutEffect(t,e)},N.useMemo=function(t,e){return R.current.useMemo(t,e)},N.useReducer=function(t,e,o){return R.current.useReducer(t,e,o)},N.useRef=function(t){return R.current.useRef(t)},N.useState=function(t){return R.current.useState(t)},N.useSyncExternalStore=function(t,e,o){return R.current.useSyncExternalStore(t,e,o)},N.useTransition=function(){return R.current.useTransition()},N.version="18.3.1",N}()),A.exports,self.onmessage=t=>{const{type:e,payload:o}=t.data;if("compute"!==e)return void self.postMessage({type:"error",error:`Unknown message type: ${e}`});const n=performance.now();try{const{packets:t,neighbors:e,localHash:i,localLat:r,localLon:a,airtimeMs:c,zeroHopNeighbors:u}=o,f=R(t,e,i,.5,r,a,0,u),l={type:"result",payload:{edges:f.edges,validatedEdges:f.validatedEdges,weakEdges:f.weakEdges,certainEdges:f.certainEdges,uncertainEdges:f.uncertainEdges,maxPacketCount:f.maxPacketCount,maxCertainCount:f.maxCertainCount,localPrefix:f.localPrefix,hubNodes:f.hubNodes,gatewayNodes:f.gatewayNodes,edgeMapEntries:Array.from(f.edgeMap.entries()),neighborAffinityEntries:Array.from(f.neighborAffinity.entries()),fullAffinityEntries:Array.from(f.fullAffinity.entries()),centralityEntries:Array.from(f.centrality.entries()),loops:f.loops,loopEdgeKeyEntries:Array.from(f.loopEdgeKeys),txDelayRecommendationEntries:Array.from(f.txDelayRecommendations.entries()),pathRegistry:(s=f.pathRegistry,{paths:s.paths,byEndpointsEntries:Array.from(s.byEndpoints.entries()),canonicalPathsEntries:Array.from(s.canonicalPaths.entries()),totalObservations:s.totalObservations,uniquePathCount:s.uniquePathCount}),edgeBetweennessEntries:Array.from(f.edgeBetweenness.entries()),backboneEdges:f.backboneEdges,nodeMobilityEntries:Array.from(f.nodeMobility.entries()),mobileNodes:f.mobileNodes,pathHealth:f.pathHealth,lastHopNeighbors:f.lastHopNeighbors,disambiguationStats:f.disambiguationStats,discoveredNodes:f.discoveredNodes,viterbiStats:f.viterbiStats},computeTimeMs:performance.now()-n};self.postMessage(l)}catch(i){const t={type:"error",error:i instanceof Error?i.message:"Unknown error in topology worker"};self.postMessage(t)}var s}}();
