!function(){"use strict";function t(t){return 1===t||0===t}function e(t){return 2===t||3===t}function o(t){return t.startsWith("0x")||t.startsWith("0X")?t.slice(2,4).toUpperCase():t.slice(0,2).toUpperCase()}function n(t,e){let n=t.forwarded_path??t.original_path;if("string"==typeof n)try{n=JSON.parse(n)}catch{return null}if(!n||!Array.isArray(n)||0===n.length)return null;const s=n.map(t=>String(t).toUpperCase()),i=e?o(e):null,a=s[s.length-1],r=null!==i&&a===i,c=r?s.slice(0,-1):[...s];return{effective:c,original:s,hadLocal:r,effectiveLength:c.length}}function s(t,e){return e-t}function i(t){return t}function a(t,e){const o=t.toUpperCase();return e.startsWith("0x")||e.startsWith("0X")?e.slice(2).toUpperCase().startsWith(o):e.toUpperCase().startsWith(o)}function r(t,e,o,n){const s=(o-t)*Math.PI/180,i=(n-e)*Math.PI/180,a=Math.sin(s/2)*Math.sin(s/2)+Math.cos(t*Math.PI/180)*Math.cos(o*Math.PI/180)*Math.sin(i/2)*Math.sin(i/2);return 2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a))*6371e3}function c(t){return t<500?1:t<2e3?.8:t<5e3?.6:t<1e4?.4:t<2e4?.2:.1}function l(t){if(t.contact_type){const e=t.contact_type.toLowerCase();if("repeater"===e||"rep"===e)return!0;if("companion"===e||"client"===e||"cli"===e)return!1;if("room server"===e||"room_server"===e||"room"===e||"server"===e)return!1}return!0===t.is_repeater||(t.is_repeater,!1)}function h(t,e){if(!t||t<=0)return.1;const o=(Math.floor(Date.now()/1e3)-t)/3600;return o<0?1:Math.exp(-o/12)}function u(t){return!(!t||t<=0)&&(Math.floor(Date.now()/1e3)-t)/3600>336}function f(t,e,o){const n=e.toUpperCase(),s=t.get(n);if(!s||0===s.candidates.length)return{hash:null,confidence:0};if(null==o?void 0:o.isLastHop)return{hash:s.bestMatch,confidence:s.confidence};if(1===(null==o?void 0:o.position))return{hash:s.bestMatch,confidence:s.confidence};if((null==o?void 0:o.position)&&s.bestMatchForPosition.has(o.position)){const t=s.bestMatchForPosition.get(o.position),e=Math.max(t.confidence,s.confidence);return{hash:t.hash,confidence:e}}if((null==o?void 0:o.adjacentPrefixes)&&o.adjacentPrefixes.length>0){let t=s.bestMatch,e=0;for(const n of s.candidates){let s=0;for(const t of o.adjacentPrefixes)s+=n.adjacentPrefixCounts.get(t.toUpperCase())||0;const i=n.combinedScore+s/Math.max(1,n.totalAdjacentObservations)*.3;i>e&&(e=i,t=n.hash)}return{hash:t,confidence:s.confidence}}return{hash:s.bestMatch,confidence:s.confidence}}function d(t,e){return`${e}:${t.join(">")}`}function p(t,e){return`${t}→${e}`}function g(o){const n=o.route??o.route_type;return t(n)?"flood":e(n)?"direct":"unknown"}const m=100;function C(t,e){return[t,e].sort().join("-")}function y(y,S,b,v=.4,M,w,P){const x=[...y].sort((t,e)=>(t.timestamp??0)-(e.timestamp??0)),k=function(t,e,i,a,c){const f=new Map,d=function(t){const e={};for(const[o,n]of Object.entries(t))l(n)&&(e[o]=n);return e}(e),p=new Map,g=void 0!==a&&void 0!==c&&(0!==a||0!==c);if(i){const t=o(i),e={hash:i,prefix:t,positionCounts:new Array(5).fill(0),totalAppearances:0,typicalPosition:0,positionConsistency:0,adjacentPrefixCounts:new Map,totalAdjacentObservations:0,latitude:a,longitude:c,distanceToLocal:0,srcGeoEvidenceScore:0,srcGeoEvidenceCount:0,lastSeenTimestamp:Math.floor(Date.now()/1e3),recencyScore:1,positionScore:0,cooccurrenceScore:0,geographicScore:1,combinedScore:0};p.set(t,[e])}for(const[n,s]of Object.entries(d)){const t=o(n),e=s.last_seen??0;if(u(e))continue;let i;const l=!0===s.zero_hop;g&&s.latitude&&s.longitude&&(0!==s.latitude||0!==s.longitude)&&(i=r(a,c,s.latitude,s.longitude));let f=.2;void 0!==i?f=i<500?1:i<2e3?.8:i<5e3?.6:i<1e4?.4:i<2e4?.2:.1:s.latitude&&s.longitude&&(f=.5),l&&(f=Math.max(f,.95));const d=h(e),m={hash:n,prefix:t,positionCounts:new Array(5).fill(0),totalAppearances:0,typicalPosition:0,positionConsistency:0,adjacentPrefixCounts:new Map,totalAdjacentObservations:0,latitude:s.latitude,longitude:s.longitude,distanceToLocal:i,srcGeoEvidenceScore:0,srcGeoEvidenceCount:0,lastSeenTimestamp:e,recencyScore:d,positionScore:0,cooccurrenceScore:0,geographicScore:f,combinedScore:0},C=p.get(t)||[];C.push(m),p.set(t,C)}for(const o of t){const t=n(o,i);if(!t||0===t.effectiveLength)continue;const a=t.effective,c=o.src_hash,l=c?e[c]:void 0,h=(null==l?void 0:l.latitude)&&(null==l?void 0:l.longitude)&&(0!==l.latitude||0!==l.longitude);for(let e=0;e<a.length;e++){const o=a[e],n=p.get(o);if(!n)continue;const i=s(e,t.effectiveLength),c=Math.min(i-1,4);for(const t of n){if(t.positionCounts[c]++,t.totalAppearances++,1===i&&n.length>1&&h&&t.latitude&&t.longitude){const e=r(l.latitude,l.longitude,t.latitude,t.longitude);let o=0;o=e<500?1:e<2e3?.8:e<5e3?.5:e<1e4?.3:.1,void 0!==t.distanceToLocal&&(t.distanceToLocal<500?o*=1.2:t.distanceToLocal<2e3?o*=1:o*=.8),t.srcGeoEvidenceScore+=o,t.srcGeoEvidenceCount++}if(e>0&&n.length>1&&t.latitude&&t.longitude){const o=a[e-1],n=p.get(o);if(n&&n.length>0){let e,o,s=0;if(1===n.length){const t=n[0];t.latitude&&t.longitude&&(e=t.latitude,o=t.longitude,s=1)}else{const t=[...n].sort((t,e)=>e.combinedScore-t.combinedScore),i=t[0],a=t[1];if(i.latitude&&i.longitude&&i.combinedScore>0){const t=a?(i.combinedScore-a.combinedScore)/i.combinedScore:1;s=Math.min(1,t+.3),s>.4&&(e=i.latitude,o=i.longitude)}}if(void 0!==e&&void 0!==o){const n=r(t.latitude,t.longitude,e,o);let i=0;i=n<500?1:n<2e3?.8:n<5e3?.5:n<1e4?.3:.1,i*=s,t.srcGeoEvidenceScore+=i,t.srcGeoEvidenceCount++}}}if(i>1&&n.length>1&&t.latitude&&t.longitude){const o=e+1;if(o<a.length){const e=a[o],n=p.get(e);if(n&&n.length>0){let e,o,s=0;if(1===n.length){const t=n[0];t.latitude&&t.longitude&&(e=t.latitude,o=t.longitude,s=1)}else{const t=[...n].sort((t,e)=>e.combinedScore-t.combinedScore),i=t[0],a=t[1];if(i.latitude&&i.longitude&&i.combinedScore>0){const t=a?(i.combinedScore-a.combinedScore)/i.combinedScore:1;s=Math.min(1,t+.3),s>.4&&(e=i.latitude,o=i.longitude)}}if(void 0!==e&&void 0!==o){const n=r(t.latitude,t.longitude,e,o);let i=0;i=n<500?1:n<2e3?.8:n<5e3?.5:n<1e4?.3:.1,i*=s,t.srcGeoEvidenceScore+=i,t.srcGeoEvidenceCount++}}}}if(e>0){const o=a[e-1];t.adjacentPrefixCounts.set(o,(t.adjacentPrefixCounts.get(o)||0)+1),t.totalAdjacentObservations++}if(e<a.length-1){const o=a[e+1];t.adjacentPrefixCounts.set(o,(t.adjacentPrefixCounts.get(o)||0)+1),t.totalAdjacentObservations++}}}}let m=1,C=1;for(const o of p.values())for(const t of o)m=Math.max(m,t.totalAppearances),C=Math.max(C,t.totalAdjacentObservations);for(const o of p.values())for(const t of o){if(t.totalAppearances>0){let e=0,o=1;for(let s=0;s<5;s++)t.positionCounts[s]>e&&(e=t.positionCounts[s],o=s+1);t.typicalPosition=o,t.positionConsistency=e/t.totalAppearances;const n=t.totalAppearances/m;t.positionScore=.6*t.positionConsistency+.4*n}if(t.totalAdjacentObservations>0&&(t.cooccurrenceScore=t.totalAdjacentObservations/C),t.combinedScore=.15*t.positionScore+.15*t.cooccurrenceScore+.35*t.geographicScore+.35*t.recencyScore,t.srcGeoEvidenceCount>0){const e=t.srcGeoEvidenceScore/t.srcGeoEvidenceCount*Math.min(t.srcGeoEvidenceCount/50,1)*.3;t.combinedScore+=e}}for(const[o,n]of p){n.sort((t,e)=>e.combinedScore-t.combinedScore);const t=n.length>0?n[0].hash:null;let e=0;if(1===n.length)e=1;else if(n.length>1){const t=n[0].combinedScore,o=n[1].combinedScore;t>0&&(e=Math.min(1,(t-o)/t)),n[0].totalAppearances>2*n[1].totalAppearances&&(e=Math.min(1,e+.2));const s=0,i=n[0].positionCounts[s]||0,a=i+(n[1].positionCounts[s]||0);if(a>=20&&i>=10){const t=i/a;if(t>=.8){const o=.3+1.5*(t-.8);e=Math.min(1,e+o)}}const r=n.reduce((t,e)=>t+e.combinedScore,0);if(r>0){const t=[],o=n.reduce((t,e)=>t+(e.positionCounts[0]||0),0);for(const e of n){const n=o*(e.combinedScore/r);t.push(n)}const s=t[0],i=s+(t[1]||0);if(i>=20&&s>=10){const t=s/i;if(t>=.6){const o=.2+1*(t-.6);e=Math.min(1,e+o)}}}const c=n[0].srcGeoEvidenceScore,l=n[1].srcGeoEvidenceScore;if(n[0].srcGeoEvidenceCount>=10&&c>1.5*l){const t=l>0?c/(c+l):1,o=Math.min(.3,.6*(t-.5));e=Math.min(1,e+o)}}const s=new Map;for(let o=1;o<=5;o++){const t=[...n].sort((t,e)=>{const n=t.positionCounts[o-1]||0;return(e.positionCounts[o-1]||0)-n});if(t.length>0&&t[0].positionCounts[o-1]>0){const e=t[0];let n=1;if(t.length>1){const s=e.positionCounts[o-1],i=s+(t[1].positionCounts[o-1]||0);n=i>0?s/i:0}s.set(o,{hash:e.hash,confidence:n})}}const i={prefix:o,candidates:n,bestMatch:t,confidence:e,isUnambiguous:1===n.length,bestMatchForPosition:s};f.set(o,i)}return f}(x,S,b,M,w),E=function(t,e,o,i,l,h){const u=new Map,d=void 0!==o&&void 0!==i&&(0!==o||0!==i);for(const[n,s]of Object.entries(e)){let t=null,e=.5;d&&s.latitude&&s.longitude&&(0!==s.latitude||0!==s.longitude)&&(t=r(o,i,s.latitude,s.longitude),e=c(t)),s.zero_hop&&(e=Math.max(e,.9)),u.set(n,{hash:n,frequency:0,directForwardCount:0,distanceMeters:t,proximityScore:e,hopPositionCounts:[0,0,0,0,0],avgHopDistance:0,typicalHopPosition:0,hopConsistencyScore:0,frequencyScore:0,combinedScore:0,avgDisambiguationConfidence:0,collisionCount:0,resolutionCount:0})}const p=new Map;for(const r of t){const t=n(r,l);if(t&&t.effectiveLength>=1){const e=t.effective;for(let o=0;o<e.length;o++){const n=e[o],i=s(o,t.effectiveLength);if(h){const t=f(h,n,{position:i,adjacentPrefixes:[...o>0?[e[o-1]]:[],...o<e.length-1?[e[o+1]]:[]],isLastHop:1===i});if(t.hash){const e=u.get(t.hash);if(e){e.frequency++,e.resolutionCount++;const o=p.get(t.hash)||0;p.set(t.hash,o+t.confidence);const s=h.get(n.toUpperCase());s&&!s.isUnambiguous&&e.collisionCount++;const a=Math.min(i-1,4);e.hopPositionCounts[a]++,1===i&&e.directForwardCount++}}}else for(const[t,e]of u)if(a(n,t)){e.frequency++;const t=Math.min(i-1,4);e.hopPositionCounts[t]++,1===i&&e.directForwardCount++}}}if((!t||0===t.effectiveLength)&&r.src_hash){const t=u.get(r.src_hash);if(t){t.frequency++,t.directForwardCount++,t.hopPositionCounts[0]++,t.resolutionCount++;const e=p.get(r.src_hash)||0;p.set(r.src_hash,e+1)}}}let g=0;for(const n of u.values())g=Math.max(g,n.frequency);for(const n of u.values()){let t=0,e=0,o=0,s=1;for(let a=0;a<n.hopPositionCounts.length;a++){const i=n.hopPositionCounts[a],r=a+1;t+=i,e+=i*r,i>o&&(o=i,s=r)}n.avgHopDistance=t>0?e/t:0,n.typicalHopPosition=s,t>0&&o>0&&(n.hopConsistencyScore=o/t),n.frequencyScore=g>0?n.frequency/g:0;const i=p.get(n.hash)||0;n.avgDisambiguationConfidence=n.resolutionCount>0?i/n.resolutionCount:0,n.combinedScore=.3*n.proximityScore+.3*n.hopConsistencyScore+.4*n.frequencyScore}return u}(x,S,M,w,b,k),H=b?o(b):null,D=new Map;for(const[t,e]of E)D.set(t,e.combinedScore);const A=new Map,L=new Map,R=new Map,j=new Map,N=new Map,U=Math.floor(Date.now()/1e3),_=(o,n,s,i,a,r,c)=>{const l=C(o,n),h=A.get(l),[u,f]=o<n?[o,n]:[n,o],d=o===u,p=t(r)||void 0===r,g=e(r),m=(t=>{if(!t||t<=0)return.1;const e=(U-t)/3600;return e<0?1:Math.exp(-e/12)})(c);if(h)h.count++,h.confidenceSum+=s,h.recencySum+=m,h.minHopDistance=Math.min(h.minHopDistance,a),a<h.hopDistanceCounts.length&&h.hopDistanceCounts[a]++,i?h.certainCount++:h.uncertainCount++,d?h.forwardCount++:h.reverseCount++,p?h.floodCount++:g&&h.directCount++;else{const t=[0,0,0,0,0,0,0,0,0,0];a<t.length&&t[a]++,A.set(l,{fromHash:u,toHash:f,key:l,count:1,confidenceSum:s,minHopDistance:a,hopDistanceCounts:t,certainCount:i?1:0,uncertainCount:i?0:1,forwardCount:d?1:0,reverseCount:d?0:1,floodCount:p?1:0,directCount:g?1:0,recencySum:m})}};for(const t of x){const e=n(t,b);if(!e)continue;const o=e.effective,a=e.effectiveLength,r=e.original,c=new Set;if(t.src_hash&&r.length>=1){const e=f(k,r[0],{position:a,adjacentPrefixes:r.length>1?[r[1]]:[]}),o=t.src_hash;if(e.hash&&e.hash!==o){const n=Object.keys(S).includes(o),s=e.confidence>=.6&&n,i=e.confidence*(n?1:.8),r=a+1,l=t.route??t.route_type;_(o,e.hash,i,s,r,l,t.timestamp),c.add(o),c.add(e.hash)}}if(b&&a>=1){const e=a-1,n=o[e],s=4===(t.type??t.payload_type);if(s){const e=N.get(n);e?(e.count++,"number"!=typeof t.rssi||isNaN(t.rssi)||(e.rssiSum+=t.rssi,e.rssiCount++),"number"!=typeof t.snr||isNaN(t.snr)||(e.snrSum+=t.snr,e.snrCount++),e.lastSeen=Math.max(e.lastSeen,t.timestamp??0)):N.set(n,{prefix:n,count:1,rssiSum:"number"!=typeof t.rssi||isNaN(t.rssi)?0:t.rssi,rssiCount:"number"!=typeof t.rssi||isNaN(t.rssi)?0:1,snrSum:"number"!=typeof t.snr||isNaN(t.snr)?0:t.snr,snrCount:"number"!=typeof t.snr||isNaN(t.snr)?0:1,lastSeen:t.timestamp??0,resolvedHashes:new Map})}const i=f(k,n,{position:1,adjacentPrefixes:e>0?[o[e-1]]:[],isLastHop:!0});if(s&&i.hash){const t=N.get(n);if(t){const e=t.resolvedHashes.get(i.hash);e?(e.count++,e.confidenceSum+=i.confidence):t.resolvedHashes.set(i.hash,{count:1,confidenceSum:i.confidence})}}if(i.hash&&i.hash!==b){const e=!0,o=i.confidence,n=t.route??t.route_type;_(i.hash,b,o,e,0,n,t.timestamp),c.add(i.hash),c.add(b),j.set(i.hash,(j.get(i.hash)||0)+1)}}for(let n=0;n<a-1;n++){const e=o[n],r=o[n+1],l=s(n,a),h=s(n+1,a),u=1===h,d=f(k,e,{position:l,adjacentPrefixes:[...n>0?[o[n-1]]:[],o[n+1]]}),p=f(k,r,{position:h,adjacentPrefixes:[o[n],...n+2<a?[o[n+2]]:[]],isLastHop:u});if(!d.hash||!p.hash)continue;if(d.hash===p.hash)continue;const g=d.confidence>=.6&&p.confidence>=.6,m=p.confidence>=.9,C=u&&p.confidence>=.6,y=g||m||C;c.add(d.hash),c.add(p.hash),n>0&&n<a-1&&R.set(d.hash,(R.get(d.hash)||0)+1);const S=m?p.confidence:d.confidence*p.confidence;if(!y&&S<v)continue;const b=i(h),M=t.route??t.route_type;_(d.hash,p.hash,S,y,b,M,t.timestamp)}for(const t of c)L.set(t,(L.get(t)||0)+1)}const F=new Map;let T=0;for(const[t,e]of L){const o=R.get(t)||0,n=e>0?o/e:0;F.set(t,n),T=Math.max(T,n)}if(T>0)for(const[t,e]of F)F.set(t,e/T);const G=new Set,O=new Set,$=[...j.values()].reduce((t,e)=>t+e,0);for(const[t,e]of j){if(t===b)continue;const o=$>0?e/$:0;if(o>=.1){G.add(t);const e=F.get(t)||0;F.set(t,Math.max(e,o))}else if(o>=.07){O.add(t);const e=F.get(t)||0;F.set(t,Math.max(e,o))}}const q=Array.from(G),z=Array.from(O),I=[],W=[],K=[];let B=0,V=0;const X=new Set(q),J=new Set;for(const t of A.values()){const e=t.confidenceSum/t.count;B=Math.max(B,t.count),V=Math.max(V,t.certainCount);const o=X.has(t.fromHash)||X.has(t.toHash),n=t.certainCount>=5,s=t.forwardCount+t.reverseCount,i=s>0?Math.min(t.forwardCount,t.reverseCount)/Math.max(t.forwardCount,t.reverseCount):0;let a="balanced";i<.7&&s>0&&(a=t.forwardCount>t.reverseCount?"forward":"reverse");const r=t.floodCount+t.directCount>0&&t.directCount>t.floodCount,c=t.count>0?t.recencySum/t.count:0,l={fromHash:t.fromHash,toHash:t.toHash,key:t.key,packetCount:t.count,avgConfidence:e,strength:0,avgRecency:c,hopDistanceFromLocal:t.minHopDistance,isHubConnection:o,isCertain:n,certainCount:t.certainCount,forwardCount:t.forwardCount,reverseCount:t.reverseCount,symmetryRatio:i,dominantDirection:a,floodCount:t.floodCount,directCount:t.directCount,isDirectPathEdge:r};I.push(l),n&&(W.push(l),J.add(t.key))}for(const t of I)!J.has(t.key)&&t.packetCount>=2&&K.push(t);for(const t of I){const e=B>0?t.packetCount/B:0;t.strength=.4*e+.4*t.avgConfidence+.2*t.avgRecency}I.sort((t,e)=>e.certainCount-t.certainCount),W.sort((t,e)=>{const o=t.certainCount+(t.isHubConnection?1e3:0);return e.certainCount+(e.isHubConnection?1e3:0)-o}),K.sort((t,e)=>t.packetCount-e.packetCount);const Q=W.slice(0,100),Y=K.slice(0,100),Z=new Map(I.map(t=>[t.key,t])),{loops:tt,loopEdgeKeys:et}=function(t,e,o=1){if(t.length<3)return{loops:[],loopEdgeKeys:new Set};const n=new Map,s=new Map;for(const l of t)s.set(l.key,l),n.has(l.fromHash)||n.set(l.fromHash,new Set),n.has(l.toHash)||n.set(l.toHash,new Set),n.get(l.fromHash).add(l.toHash),n.get(l.toHash).add(l.fromHash);const i=[],a=new Set,r=new Set;function c(t,e,o){if(t===e)return[t];const s=new Set([t]),i=[{node:t,path:[t]}];for(;i.length>0;){const{node:t,path:a}=i.shift(),r=n.get(t);if(r)for(const n of r)if(C(t,n)!==o){if(n===e)return[...a,n];s.has(n)||(s.add(n),i.push({node:n,path:[...a,n]}))}}return null}for(const l of t){const t=c(l.fromHash,l.toHash,l.key);if(t&&t.length>=2){const n=t,c=[l.key];for(let e=0;e<t.length-1;e++){const o=C(t[e],t[e+1]);c.push(o)}const h=[...n].sort().join(",");if(r.has(h))continue;r.add(h);let u=0,f=1/0;for(const t of c){const e=s.get(t);e&&(u+=e.certainCount,f=Math.min(f,e.certainCount),a.add(t))}const d=c.length>0?u/c.length:0,p=!!e&&n.includes(e),g={id:`loop-${i.length}`,edgeKeys:c,nodes:n,size:c.length,avgCertainCount:d,minCertainCount:f===1/0?0:f,includesLocal:p,strength:o>0?f===1/0?0:f/o:0};i.push(g)}}return i.sort((t,e)=>t.includesLocal!==e.includesLocal?t.includesLocal?-1:1:e.strength-t.strength),{loops:i,loopEdgeKeys:a}}(W,b,V);for(const t of I)t.isLoopEdge=et.has(t.key);const ot=function(t,e){const o=new Map,n=new Map;let s=0;for(const r of t){if(!r.src_hash)continue;const t=r.original_path??r.forwarded_path;if(!t||!Array.isArray(t)||0===t.length)continue;const n=t.map(t=>"string"==typeof t?t.toUpperCase().slice(0,2):String(t).toUpperCase().slice(0,2)),i=e||"unknown",a=r.src_hash,c=d(n,a);let l=o.get(c);l||(l={id:c,hops:n,srcHash:a,dstHash:i,observationCount:0,firstSeen:r.timestamp,lastSeen:r.timestamp,routeType:g(r),hopCount:n.length},o.set(c,l)),l.observationCount++,l.lastSeen=Math.max(l.lastSeen,r.timestamp),l.firstSeen=Math.min(l.firstSeen,r.timestamp),s++,"direct"===g(r)&&"direct"!==l.routeType&&(l.routeType="direct")}const i=Array.from(o.values());for(const r of i){const t=p(r.srcHash,r.dstHash),e=n.get(t)||[];e.push(r),n.set(t,e)}for(const r of n.values())r.sort((t,e)=>e.observationCount-t.observationCount);const a=new Map;for(const[r,c]of n)c.length>0&&a.set(r,c[0]);return{paths:i,byEndpoints:n,canonicalPaths:a,totalObservations:s,uniquePathCount:i.length}}(x,b),nt=function(t,e,o,n){const s=new Map;if(0===t.length||0===o.length)return s;const i=t=>{const e=.2*Math.round(t/.2);return Math.max(0,Math.min(5,e))},a=t=>Math.floor(5*t),r=new Set;for(const m of t)r.add(m.fromHash),r.add(m.toHash);const c=o.map(t=>t.timestamp).filter(t=>void 0!==t&&t>0).sort((t,e)=>t-e),l=c.length>=2?(c[c.length-1]-c[0])/60:1,h=new Map;for(const m of t)h.has(m.fromHash)||h.set(m.fromHash,[]),h.has(m.toHash)||h.set(m.toHash,[]),h.get(m.fromHash).push(m),h.get(m.toHash).push(m);const u=new Set;for(const m of t)m.isLoopEdge&&u.add(m.key);const f=new Set;for(const[,m]of n.canonicalPaths)for(const t of m.hops)f.add(t.toUpperCase());const d=new Map;for(const m of r){const t=h.get(m)||[];if(0===t.length)continue;const e=m.startsWith("0x")?m.slice(2,4).toUpperCase():m.slice(0,2).toUpperCase(),o=new Set;let s=0,i=0,a=0,r=0,c=0,f=0,p=0;for(const n of t){const t=n.fromHash===m?n.toHash:n.fromHash;o.add(t),s+=n.packetCount,i+=n.certainCount,a=Math.max(a,n.certainCount),r+=n.symmetryRatio,c+=n.floodCount,n.isDirectPathEdge&&f++,u.has(n.key)&&p++}const g=o.size,C=t.length>0?r/t.length:0,y=t.length>0?i/t.length:0,S=n.paths.filter(t=>t.hops.some(t=>t.toUpperCase()===e)),b=S.length;let v=0;for(const[,l]of n.canonicalPaths)l.hops.some(t=>t.toUpperCase()===e)&&v++;const M=S.length>0?S.reduce((t,e)=>t+e.hopCount,0)/S.length:0;d.set(m,{neighborCount:g,totalEdgePackets:s,maxEdgeCertainCount:a,avgEdgeCertainCount:y,avgSymmetry:C,forwardingBurden:0,floodForwardRatio:s>0?c/s:0,pathCount:b,canonicalPathCount:v,avgPathLength:M,loopParticipation:t.length>0?p/t.length:0,isInLoop:p>0,edgeDensity:0,trafficRate:l>0?s/l:0,directPathEdgeRatio:t.length>0?f/t.length:0})}const p=[],g=[],C=[],y=[];for(const[,P]of d)P.totalEdgePackets>=m&&(p.push(P.totalEdgePackets),g.push(P.neighborCount),C.push(P.pathCount),y.push(P.trafficRate));p.sort((t,e)=>t-e),g.sort((t,e)=>t-e),C.sort((t,e)=>t-e),y.sort((t,e)=>t-e);const S=(t,e)=>{if(0===t.length)return.5;const o=t.findIndex(t=>t>=e);return-1===o?1:0===o?0:o/t.length},b=g.length>0?Math.max(...g):1;for(const[,m]of d)m.forwardingBurden=S(p,m.totalEdgePackets),m.edgeDensity=b>0?m.neighborCount/b:0;const v=new Map;for(const P of r){const t=d.get(P);if(!t||t.totalEdgePackets<m)continue;const e=P.startsWith("0x")?P.slice(2,4).toUpperCase():P.slice(0,2).toUpperCase(),s=t.forwardingBurden,i=S(g,t.neighborCount),a=.3*t.avgSymmetry,r=Math.min(1,i+a),c=.6*(n.canonicalPaths.size>0?t.canonicalPathCount/n.canonicalPaths.size:0)+.4*S(C,t.pathCount),l=t.loopParticipation,h=.3*s+.3*r+.2*c+.2*l;let u,f=.4+3.6*h;(h<.1&&t.neighborCount<=2||f<.4)&&(f=.4),u=h>=.7&&t.neighborCount>=4?"backbone":t.neighborCount>=4?"hub":h>=.3&&t.neighborCount>=2?"relay":"edge";const p=n.paths.filter(t=>t.hops.some(t=>t.toUpperCase()===e)).flatMap(t=>{const o=t.hops.findIndex(t=>t.toUpperCase()===e);return o>=0?[o+1]:[]}),y=p.length>0?p.reduce((t,e)=>t+e,0)/p.length:0;let b=0;p.length>1&&(b=p.reduce((t,e)=>t+Math.pow(e-y,2),0)/p.length);const M=.3*Math.min(t.avgEdgeCertainCount/10,1)+.3*Math.min(o.length/1e3,1)+.4*t.avgSymmetry;let w;w=o.length<m?"insufficient":o.length<500?"low":o.length<1e3?"medium":"high",v.set(P,{compositeScore:h,rawFloodDelay:f,networkRole:u,collisionRisk:r,floodParticipationRate:t.floodForwardRatio,avgPathPosition:y,pathPositionVariance:b,pathDiversity:t.pathCount,trafficIntensity:t.trafficRate,confidence:M,observationSymmetry:t.avgSymmetry,dataConfidence:w,factors:{forwarding:s,collision:r,criticality:c,redundancy:l}})}const M=new Map;for(const[m,P]of v){const t=a(i(P.rawFloodDelay));M.has(t)||M.set(t,[]),M.get(t).push(m)}const w=new Map;for(const[,m]of M){if(m.length<=1){if(1===m.length){const t=m[0],e=v.get(t);w.set(t,i(e.rawFloodDelay))}continue}const t=[...m].sort((t,e)=>{const o=v.get(t),n=v.get(e);return o.compositeScore-n.compositeScore});for(let e=0;e<t.length;e++){const o=t[e],n=v.get(o),s=e%3*.2;w.set(o,i(n.rawFloodDelay+s))}}for(const P of r){const t=d.get(P);if(!t||t.totalEdgePackets<m){s.set(P,{floodFactor:0,directFactor:0,floodSlots:0,directSlots:0,floodDelaySec:0,directDelaySec:0,txDelayFactor:0,directTxDelayFactor:0,trafficIntensity:0,directNeighborCount:(null==t?void 0:t.neighborCount)??0,collisionRisk:0,confidence:0,insufficientData:!0,networkRole:"edge",rationale:"Insufficient data (<100 packets observed)",adjustment:"stable",avgPathPosition:0,pathPositionVariance:0,floodParticipationRate:0,pathDiversity:0,positionDelayMs:0,observationSymmetry:(null==t?void 0:t.avgSymmetry)??0,dataConfidence:"insufficient"});continue}const e=v.get(P),o=w.get(P)??i(e.rawFloodDelay),n=i(.28*o),r=a(o),c=a(n);let l,h={backbone:`Backbone: ${t.neighborCount} neighbors, ${Math.round(100*t.avgSymmetry)}% symmetric`,hub:`Hub: ${t.neighborCount} neighbors`,relay:`Relay: ${Math.round(100*t.avgSymmetry)}% symmetric traffic`,edge:"Edge node"}[e.networkRole];e.observationSymmetry>=.6?h+=". High bidirectional visibility (+1 slot)":e.observationSymmetry<.3&&(h+=". ⚠️ Low symmetry (possible observer bias)"),"low"===e.dataConfidence&&(h+=". Limited data"),l=r>a(1)?"increase":r<a(1)?"decrease":"stable";const u=0;s.set(P,{floodFactor:o,directFactor:n,floodSlots:r,directSlots:c,floodDelaySec:o,directDelaySec:n,txDelayFactor:o,directTxDelayFactor:n,trafficIntensity:Math.round(10*e.trafficIntensity)/10,directNeighborCount:t.neighborCount,collisionRisk:Math.round(100*e.collisionRisk)/100,confidence:e.confidence,insufficientData:!1,networkRole:e.networkRole,rationale:h,adjustment:l,avgPathPosition:Math.round(10*e.avgPathPosition)/10,pathPositionVariance:Math.round(100*e.pathPositionVariance)/100,floodParticipationRate:Math.round(100*e.floodParticipationRate)/100,pathDiversity:e.pathDiversity,positionDelayMs:u,observationSymmetry:Math.round(100*e.observationSymmetry)/100,dataConfidence:e.dataConfidence})}return s}(I,0,x,ot),st=function(t,e){const n=new Map,s=new Map(e.map(t=>[t.key,t]));for(const o of e)n.set(o.key,0);if(0===t.paths.length)return n;for(const a of t.paths)for(let t=0;t<a.hops.length-1;t++){const s=a.hops[t],i=a.hops[t+1];for(const t of e){const e=o(t.fromHash),r=o(t.toHash);if(e===s&&r===i||e===i&&r===s){const e=n.get(t.key)||0;n.set(t.key,e+a.observationCount);break}}}const i=Math.max(...n.values(),1);for(const[o,a]of n)n.set(o,a/i);for(const[o,a]of n){const t=s.get(o);if(t){const e=.5+.5*t.symmetryRatio;n.set(o,a*e)}}return n}(ot,I),it=function(t,e=3,o=.3){return[...t.entries()].filter(([,t])=>t>=o).sort((t,e)=>e[1]-t[1]).slice(0,e).map(([t])=>t)}(st,3,.3),{nodeMobility:at,mobileNodes:rt}=function(t,e){const o=new Map,n=[];if(0===t.paths.length)return{nodeMobility:o,mobileNodes:n};const s=36e5,i=t.paths.map(t=>t.lastSeen).sort((t,e)=>t-e),a=i[0],r=i[i.length-1],c=Math.ceil((r-a)/s)||1,l=new Map;for(const h of t.paths){const t=Math.floor((h.lastSeen-a)/s);for(const o of h.hops){let n=o;for(const[t]of Object.entries(e))if((t.startsWith("0x")?t.slice(2,4).toUpperCase():t.slice(0,2).toUpperCase())===o.toUpperCase()){n=t;break}let s=l.get(n);s||(s={paths:new Set,firstSeen:h.firstSeen,lastSeen:h.lastSeen,windowPresence:new Set},l.set(n,s)),s.paths.add(h.id),s.firstSeen=Math.min(s.firstSeen,h.firstSeen),s.lastSeen=Math.max(s.lastSeen,h.lastSeen),s.windowPresence.add(t)}}for(const[h,u]of l){const t=u.paths.size,e=u.lastSeen-u.firstSeen,s=e>0?e/36e5:0,i=c>0?u.windowPresence.size/c:1,a=(1-i)*(1-.5*Math.min(t/10,1)),r=a>.3,l={hash:h,pathVolatility:a,pathDiversity:t,avgPathLifespanHours:s,isMobile:r,lastSeen:u.lastSeen,activeWindowRatio:i};o.set(h,l),r&&n.push(h)}return n.sort((t,e)=>{var n,s;const i=(null==(n=o.get(t))?void 0:n.pathVolatility)??0;return((null==(s=o.get(e))?void 0:s.pathVolatility)??0)-i}),{nodeMobility:o,mobileNodes:n}}(ot,S),ct=function(t,e,n,s=20){const i=[];if(0===t.paths.length)return i;const a=new Map;for(const u of e){const t=o(u.fromHash),e=o(u.toHash);a.set(`${t}>${e}`,u),a.set(`${e}>${t}`,u)}const r=new Set;for(const u of n)r.add(o(u));const c=new Map;for(const o of t.paths){if(0===o.hops.length)continue;const t=o.hops[o.hops.length-1],e=c.get(t)||[];e.push(o.id),c.set(t,e)}const l=[...t.paths].sort((t,e)=>e.observationCount-t.observationCount),h=Date.now();for(const o of l.slice(0,s)){if(o.hops.length<2)continue;let t=0,e=1/0,n=null,s=0,l=!1;for(let i=0;i<o.hops.length-1;i++){const c=o.hops[i],h=o.hops[i+1],u=`${c}>${h}`,f=a.get(u);if(f){const o=f.packetCount>0?f.certainCount/f.packetCount:0;t+=o,s++,o<e&&(e=o,n=f.key)}else t+=.1,s++,.1<e&&(e=.1,n=C(c,h));(r.has(c)||r.has(h))&&(l=!0)}const u=s>0?t/s:0,f=e===1/0?0:e,d=(h-o.lastSeen)/36e5,p=Math.exp(-d/24),g=o.observationCount>10&&d<12?.5+.5*(1-d/12):d>48?-.5:0,m=o.hops[o.hops.length-1],y=c.get(m)||[],S=Math.max(0,y.length-1),b="direct"===o.routeType?20:30,v=o.hops.length*b,M=.4*u,w=.3*p,P=(g+1)/2*.15,x=.15*Math.min(S/3,1),k=Math.round(100*(M+w+P+x))/100;i.push({pathKey:o.id,hops:[...o.hops],healthScore:k,weakestLinkKey:n,weakestLinkConfidence:Math.round(100*f)/100,avgEdgeCertainty:Math.round(100*u)/100,observationTrend:Math.round(100*g)/100,alternatePathsCount:S,estimatedLatencyMs:v,observationCount:o.observationCount,routeType:"unknown"===o.routeType?"mixed":o.routeType,lastSeen:o.lastSeen,involvesHub:l})}return i.sort((t,e)=>e.healthScore-t.healthScore),i}(ot,I,q,20),lt=[];for(const t of N.values()){let e=null,o=0,n=0;for(const[s,i]of t.resolvedHashes){if(s===b)continue;const t=i.count>0?i.confidenceSum/i.count:0,a=i.count*t;a>o&&(o=a,e=s,n=t)}e&&lt.push({hash:e,prefix:t.prefix,count:t.count,confidence:n,avgRssi:t.rssiCount>0?t.rssiSum/t.rssiCount:null,avgSnr:t.snrCount>0?t.snrSum/t.snrCount:null,lastSeen:t.lastSeen})}lt.sort((t,e)=>e.count-t.count);let ht=0,ut=0;const ft=[],dt=[];let pt=0;for(const[t,e]of k){ht+=e.confidence;const o=e.candidates.length;e.isUnambiguous||(ut++,dt.push({prefix:t,candidateCount:o}),e.confidence<.5&&ft.push(t));for(const e of E.values())if(e.hash.toUpperCase().startsWith(t)||e.hash.slice(2).toUpperCase().startsWith(t)){pt+=e.resolutionCount;break}}dt.sort((t,e)=>e.candidateCount-t.candidateCount);const gt=dt.slice(0,5);return{edges:I,validatedEdges:Q,weakEdges:Y,certainEdges:Q,uncertainEdges:[],edgeMap:Z,maxPacketCount:B,maxCertainCount:V,neighborAffinity:D,fullAffinity:E,localPrefix:H,centrality:F,hubNodes:q,gatewayNodes:z,loops:tt,loopEdgeKeys:et,txDelayRecommendations:nt,pathRegistry:ot,edgeBetweenness:st,backboneEdges:it,nodeMobility:at,mobileNodes:rt,pathHealth:ct,lastHopNeighbors:lt,disambiguationStats:{totalPrefixes:k.size,unambiguousPrefixes:k.size-ut,collisionPrefixes:ut,collisionRate:k.size>0?Math.round(ut/k.size*1e3)/10:0,avgConfidence:k.size>0?Math.round(ht/k.size*1e3)/1e3:0,lowConfidencePrefixes:ft,highCollisionPrefixes:gt,totalResolutions:pt}}}self.onmessage=t=>{const{type:e,payload:o}=t.data;if("compute"!==e)return void self.postMessage({type:"error",error:`Unknown message type: ${e}`});const n=performance.now();try{const{packets:t,neighbors:e,localHash:i,localLat:a,localLon:r,airtimeMs:c}=o,l=y(t,e,i,.5,a,r),h={type:"result",payload:{edges:l.edges,validatedEdges:l.validatedEdges,weakEdges:l.weakEdges,certainEdges:l.certainEdges,uncertainEdges:l.uncertainEdges,maxPacketCount:l.maxPacketCount,maxCertainCount:l.maxCertainCount,localPrefix:l.localPrefix,hubNodes:l.hubNodes,gatewayNodes:l.gatewayNodes,edgeMapEntries:Array.from(l.edgeMap.entries()),neighborAffinityEntries:Array.from(l.neighborAffinity.entries()),fullAffinityEntries:Array.from(l.fullAffinity.entries()),centralityEntries:Array.from(l.centrality.entries()),loops:l.loops,loopEdgeKeyEntries:Array.from(l.loopEdgeKeys),txDelayRecommendationEntries:Array.from(l.txDelayRecommendations.entries()),pathRegistry:(s=l.pathRegistry,{paths:s.paths,byEndpointsEntries:Array.from(s.byEndpoints.entries()),canonicalPathsEntries:Array.from(s.canonicalPaths.entries()),totalObservations:s.totalObservations,uniquePathCount:s.uniquePathCount}),edgeBetweennessEntries:Array.from(l.edgeBetweenness.entries()),backboneEdges:l.backboneEdges,nodeMobilityEntries:Array.from(l.nodeMobility.entries()),mobileNodes:l.mobileNodes,pathHealth:l.pathHealth,lastHopNeighbors:l.lastHopNeighbors,disambiguationStats:l.disambiguationStats},computeTimeMs:performance.now()-n};self.postMessage(h)}catch(i){const t={type:"error",error:i instanceof Error?i.message:"Unknown error in topology worker"};self.postMessage(t)}var s}}();
